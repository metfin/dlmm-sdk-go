// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package lb_clmm

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "add_liquidity" instruction.
func NewAddLiquidityInstruction(
	// Params:
	liquidityParameterParam LiquidityParameter,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParameterParam`:
		err = enc__.Encode(liquidityParameterParam)
		if err != nil {
			return nil, errors.NewField("liquidityParameterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 10 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 11 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 12 "token_x_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 13 "token_y_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_liquidity2" instruction.
func NewAddLiquidity2Instruction(
	// Params:
	liquidityParameterParam LiquidityParameter,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidity2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParameterParam`:
		err = enc__.Encode(liquidityParameterParam)
		if err != nil {
			return nil, errors.NewField("liquidityParameterParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 10 "token_x_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 11 "token_y_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 12 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 13 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_liquidity_by_strategy" instruction.
func NewAddLiquidityByStrategyInstruction(
	// Params:
	liquidityParameterParam LiquidityParameterByStrategy,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidityByStrategy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParameterParam`:
		err = enc__.Encode(liquidityParameterParam)
		if err != nil {
			return nil, errors.NewField("liquidityParameterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 10 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 11 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 12 "token_x_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 13 "token_y_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_liquidity_by_strategy2" instruction.
func NewAddLiquidityByStrategy2Instruction(
	// Params:
	liquidityParameterParam LiquidityParameterByStrategy,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidityByStrategy2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParameterParam`:
		err = enc__.Encode(liquidityParameterParam)
		if err != nil {
			return nil, errors.NewField("liquidityParameterParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 10 "token_x_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 11 "token_y_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 12 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 13 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_liquidity_by_strategy_one_side" instruction.
func NewAddLiquidityByStrategyOneSideInstruction(
	// Params:
	liquidityParameterParam LiquidityParameterByStrategyOneSide,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidityByStrategyOneSide[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParameterParam`:
		err = enc__.Encode(liquidityParameterParam)
		if err != nil {
			return nil, errors.NewField("liquidityParameterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccount, true, false))
		// Account 4 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 5 "token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 6 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 7 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 8 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 11 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_liquidity_by_weight" instruction.
func NewAddLiquidityByWeightInstruction(
	// Params:
	liquidityParameterParam LiquidityParameterByWeight,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidityByWeight[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParameterParam`:
		err = enc__.Encode(liquidityParameterParam)
		if err != nil {
			return nil, errors.NewField("liquidityParameterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 10 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 11 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 12 "token_x_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 13 "token_y_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_liquidity_one_side" instruction.
func NewAddLiquidityOneSideInstruction(
	// Params:
	liquidityParameterParam LiquidityOneSideParameter,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidityOneSide[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParameterParam`:
		err = enc__.Encode(liquidityParameterParam)
		if err != nil {
			return nil, errors.NewField("liquidityParameterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccount, true, false))
		// Account 4 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 5 "token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 6 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 7 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 8 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 11 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_liquidity_one_side_precise" instruction.
func NewAddLiquidityOneSidePreciseInstruction(
	// Params:
	parameterParam AddLiquiditySingleSidePreciseParameter,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidityOneSidePrecise[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `parameterParam`:
		err = enc__.Encode(parameterParam)
		if err != nil {
			return nil, errors.NewField("parameterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccount, true, false))
		// Account 4 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 5 "token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 6 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 7 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 8 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 11 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_liquidity_one_side_precise2" instruction.
func NewAddLiquidityOneSidePrecise2Instruction(
	// Params:
	liquidityParameterParam AddLiquiditySingleSidePreciseParameter2,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidityOneSidePrecise2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParameterParam`:
		err = enc__.Encode(liquidityParameterParam)
		if err != nil {
			return nil, errors.NewField("liquidityParameterParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccount, true, false))
		// Account 4 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 5 "token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 6 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 7 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim_fee" instruction.
func NewClaimFeeInstruction(
	lbPairAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 2 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 3 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 4 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 8 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 9 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 10 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 11 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 12 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 13 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "claim_fee2" instruction.
func NewClaimFee2Instruction(
	// Params:
	minBinIdParam int32,
	maxBinIdParam int32,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	tokenProgramXAccount solanago.PublicKey,
	tokenProgramYAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClaimFee2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `minBinIdParam`:
		err = enc__.Encode(minBinIdParam)
		if err != nil {
			return nil, errors.NewField("minBinIdParam", err)
		}
		// Serialize `maxBinIdParam`:
		err = enc__.Encode(maxBinIdParam)
		if err != nil {
			return nil, errors.NewField("maxBinIdParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 2 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 3 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 4 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 5 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 6 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "token_program_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramXAccount, false, false))
		// Account 10 "token_program_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramYAccount, false, false))
		// Account 11 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 12 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 13 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim_reward" instruction.
func NewClaimRewardInstruction(
	// Params:
	rewardIndexParam uint64,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	rewardVaultAccount solanago.PublicKey,
	rewardMintAccount solanago.PublicKey,
	userTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClaimReward[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 2 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 3 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 4 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 5 "reward_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardVaultAccount, true, false))
		// Account 6 "reward_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardMintAccount, false, false))
		// Account 7 "user_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccountAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 10 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim_reward2" instruction.
func NewClaimReward2Instruction(
	// Params:
	rewardIndexParam uint64,
	minBinIdParam int32,
	maxBinIdParam int32,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	rewardVaultAccount solanago.PublicKey,
	rewardMintAccount solanago.PublicKey,
	userTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClaimReward2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `minBinIdParam`:
		err = enc__.Encode(minBinIdParam)
		if err != nil {
			return nil, errors.NewField("minBinIdParam", err)
		}
		// Serialize `maxBinIdParam`:
		err = enc__.Encode(maxBinIdParam)
		if err != nil {
			return nil, errors.NewField("maxBinIdParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 2 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 3 "reward_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardVaultAccount, true, false))
		// Account 4 "reward_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardMintAccount, false, false))
		// Account 5 "user_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccountAccount, true, false))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_claim_protocol_fee_operator" instruction.
func NewCloseClaimProtocolFeeOperatorInstruction(
	claimFeeOperatorAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "claim_fee_operator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(claimFeeOperatorAccount, true, false))
		// Account 1 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 2 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "close_position" instruction.
func NewClosePositionInstruction(
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 3 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 4 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 5 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 6 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 7 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "close_position2" instruction.
func NewClosePosition2Instruction(
	positionAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 2 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "close_position_if_empty" instruction.
func NewClosePositionIfEmptyInstruction(
	positionAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 2 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "close_preset_parameter" instruction.
func NewClosePresetParameterInstruction(
	presetParameterAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "preset_parameter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(presetParameterAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 2 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "close_preset_parameter2" instruction.
func NewClosePresetParameter2Instruction(
	presetParameterAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "preset_parameter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(presetParameterAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 2 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "create_claim_protocol_fee_operator" instruction.
func NewCreateClaimProtocolFeeOperatorInstruction(
	claimFeeOperatorAccount solanago.PublicKey,
	operatorAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "claim_fee_operator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(claimFeeOperatorAccount, true, false))
		// Account 1 "operator": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operatorAccount, false, false))
		// Account 2 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "decrease_position_length" instruction.
func NewDecreasePositionLengthInstruction(
	// Params:
	lengthToRemoveParam uint16,
	sideParam uint8,

	// Accounts:
	rentReceiverAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DecreasePositionLength[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lengthToRemoveParam`:
		err = enc__.Encode(lengthToRemoveParam)
		if err != nil {
			return nil, errors.NewField("lengthToRemoveParam", err)
		}
		// Serialize `sideParam`:
		err = enc__.Encode(sideParam)
		if err != nil {
			return nil, errors.NewField("sideParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 1 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 2 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "for_idl_type_generation_do_not_call" instruction.
func NewForIdlTypeGenerationDoNotCallInstruction(
	// Params:
	ixParam DummyIx,

	// Accounts:
	dummyZcAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ForIdlTypeGenerationDoNotCall[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `ixParam`:
		err = enc__.Encode(ixParam)
		if err != nil {
			return nil, errors.NewField("ixParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "dummy_zc_account": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(dummyZcAccountAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "fund_reward" instruction.
func NewFundRewardInstruction(
	// Params:
	rewardIndexParam uint64,
	amountParam uint64,
	carryForwardParam bool,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	rewardVaultAccount solanago.PublicKey,
	rewardMintAccount solanago.PublicKey,
	funderTokenAccountAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	binArrayAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FundReward[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `carryForwardParam`:
		err = enc__.Encode(carryForwardParam)
		if err != nil {
			return nil, errors.NewField("carryForwardParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "reward_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardVaultAccount, true, false))
		// Account 2 "reward_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardMintAccount, false, false))
		// Account 3 "funder_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderTokenAccountAccount, true, false))
		// Account 4 "funder": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, false, true))
		// Account 5 "bin_array": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayAccount, true, false))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "go_to_a_bin" instruction.
func NewGoToABinInstruction(
	// Params:
	binIdParam int32,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	fromBinArrayAccount solanago.PublicKey,
	toBinArrayAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_GoToABin[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `binIdParam`:
		err = enc__.Encode(binIdParam)
		if err != nil {
			return nil, errors.NewField("binIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, false, false))
		// Account 2 "from_bin_array": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(fromBinArrayAccount, false, false))
		// Account 3 "to_bin_array": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(toBinArrayAccount, false, false))
		// Account 4 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "increase_oracle_length" instruction.
func NewIncreaseOracleLengthInstruction(
	// Params:
	lengthToAddParam uint64,

	// Accounts:
	oracleAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IncreaseOracleLength[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lengthToAddParam`:
		err = enc__.Encode(lengthToAddParam)
		if err != nil {
			return nil, errors.NewField("lengthToAddParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 1 "funder": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "increase_position_length" instruction.
func NewIncreasePositionLengthInstruction(
	// Params:
	lengthToAddParam uint16,
	sideParam uint8,

	// Accounts:
	funderAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IncreasePositionLength[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lengthToAddParam`:
		err = enc__.Encode(lengthToAddParam)
		if err != nil {
			return nil, errors.NewField("lengthToAddParam", err)
		}
		// Serialize `sideParam`:
		err = enc__.Encode(sideParam)
		if err != nil {
			return nil, errors.NewField("sideParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "funder": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, true, true))
		// Account 1 "lb_pair": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, false, false))
		// Account 2 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 3 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 6 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_bin_array" instruction.
func NewInitializeBinArrayInstruction(
	// Params:
	indexParam int64,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeBinArray[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `indexParam`:
		err = enc__.Encode(indexParam)
		if err != nil {
			return nil, errors.NewField("indexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, false, false))
		// Account 1 "bin_array": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayAccount, true, false))
		// Account 2 "funder": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_bin_array_bitmap_extension" instruction.
func NewInitializeBinArrayBitmapExtensionInstruction(
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, false, false))
		// Account 1 "bin_array_bitmap_extension": Writable, Non-signer, Required
		// Initialize an account to store if a bin array is initialized.
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 2 "funder": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_customizable_permissionless_lb_pair" instruction.
func NewInitializeCustomizablePermissionlessLbPairInstruction(
	// Params:
	paramsParam CustomizableParams,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	tokenMintXAccount solanago.PublicKey,
	tokenMintYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeCustomizablePermissionlessLbPair[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 2 "token_mint_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintXAccount, false, false))
		// Account 3 "token_mint_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintYAccount, false, false))
		// Account 4 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 5 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 6 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 7 "user_token_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, false, false))
		// Account 8 "funder": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, true, true))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 11 "user_token_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, false, false))
		// Account 12 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 13 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_customizable_permissionless_lb_pair2" instruction.
func NewInitializeCustomizablePermissionlessLbPair2Instruction(
	// Params:
	paramsParam CustomizableParams,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	tokenMintXAccount solanago.PublicKey,
	tokenMintYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	tokenBadgeXAccount solanago.PublicKey,
	tokenBadgeYAccount solanago.PublicKey,
	tokenProgramXAccount solanago.PublicKey,
	tokenProgramYAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeCustomizablePermissionlessLbPair2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 2 "token_mint_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintXAccount, false, false))
		// Account 3 "token_mint_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintYAccount, false, false))
		// Account 4 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 5 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 6 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 7 "user_token_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, false, false))
		// Account 8 "funder": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, true, true))
		// Account 9 "token_badge_x": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeXAccount, false, false))
		// Account 10 "token_badge_y": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeYAccount, false, false))
		// Account 11 "token_program_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramXAccount, false, false))
		// Account 12 "token_program_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramYAccount, false, false))
		// Account 13 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 14 "user_token_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, false, false))
		// Account 15 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 16 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_lb_pair" instruction.
func NewInitializeLbPairInstruction(
	// Params:
	activeIdParam int32,
	binStepParam uint16,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	tokenMintXAccount solanago.PublicKey,
	tokenMintYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	presetParameterAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeLbPair[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `activeIdParam`:
		err = enc__.Encode(activeIdParam)
		if err != nil {
			return nil, errors.NewField("activeIdParam", err)
		}
		// Serialize `binStepParam`:
		err = enc__.Encode(binStepParam)
		if err != nil {
			return nil, errors.NewField("binStepParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 2 "token_mint_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintXAccount, false, false))
		// Account 3 "token_mint_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintYAccount, false, false))
		// Account 4 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 5 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 6 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 7 "preset_parameter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(presetParameterAccount, false, false))
		// Account 8 "funder": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, true, true))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 11 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 12 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 13 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_lb_pair2" instruction.
func NewInitializeLbPair2Instruction(
	// Params:
	paramsParam InitializeLbPair2Params,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	tokenMintXAccount solanago.PublicKey,
	tokenMintYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	presetParameterAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	tokenBadgeXAccount solanago.PublicKey,
	tokenBadgeYAccount solanago.PublicKey,
	tokenProgramXAccount solanago.PublicKey,
	tokenProgramYAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeLbPair2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 2 "token_mint_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintXAccount, false, false))
		// Account 3 "token_mint_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintYAccount, false, false))
		// Account 4 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 5 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 6 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 7 "preset_parameter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(presetParameterAccount, false, false))
		// Account 8 "funder": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, true, true))
		// Account 9 "token_badge_x": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeXAccount, false, false))
		// Account 10 "token_badge_y": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeYAccount, false, false))
		// Account 11 "token_program_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramXAccount, false, false))
		// Account 12 "token_program_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramYAccount, false, false))
		// Account 13 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_permission_lb_pair" instruction.
func NewInitializePermissionLbPairInstruction(
	// Params:
	ixDataParam InitPermissionPairIx,

	// Accounts:
	baseAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	tokenMintXAccount solanago.PublicKey,
	tokenMintYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	tokenBadgeXAccount solanago.PublicKey,
	tokenBadgeYAccount solanago.PublicKey,
	tokenProgramXAccount solanago.PublicKey,
	tokenProgramYAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePermissionLbPair[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `ixDataParam`:
		err = enc__.Encode(ixDataParam)
		if err != nil {
			return nil, errors.NewField("ixDataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "base": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(baseAccount, false, true))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "token_mint_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintXAccount, false, false))
		// Account 4 "token_mint_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintYAccount, false, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 8 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 9 "token_badge_x": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeXAccount, false, false))
		// Account 10 "token_badge_y": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeYAccount, false, false))
		// Account 11 "token_program_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramXAccount, false, false))
		// Account 12 "token_program_y": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramYAccount, false, false))
		// Account 13 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 14 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 15 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 16 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_position" instruction.
func NewInitializePositionInstruction(
	// Params:
	lowerBinIdParam int32,
	widthParam int32,

	// Accounts:
	payerAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePosition[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lowerBinIdParam`:
		err = enc__.Encode(lowerBinIdParam)
		if err != nil {
			return nil, errors.NewField("lowerBinIdParam", err)
		}
		// Serialize `widthParam`:
		err = enc__.Encode(widthParam)
		if err != nil {
			return nil, errors.NewField("widthParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "position": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, true))
		// Account 2 "lb_pair": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, false, false))
		// Account 3 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 6 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 7 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_position_by_operator" instruction.
func NewInitializePositionByOperatorInstruction(
	// Params:
	lowerBinIdParam int32,
	widthParam int32,
	feeOwnerParam solanago.PublicKey,
	lockReleasePointParam uint64,

	// Accounts:
	payerAccount solanago.PublicKey,
	baseAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	operatorAccount solanago.PublicKey,
	operatorTokenXAccount solanago.PublicKey,
	ownerTokenXAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePositionByOperator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lowerBinIdParam`:
		err = enc__.Encode(lowerBinIdParam)
		if err != nil {
			return nil, errors.NewField("lowerBinIdParam", err)
		}
		// Serialize `widthParam`:
		err = enc__.Encode(widthParam)
		if err != nil {
			return nil, errors.NewField("widthParam", err)
		}
		// Serialize `feeOwnerParam`:
		err = enc__.Encode(feeOwnerParam)
		if err != nil {
			return nil, errors.NewField("feeOwnerParam", err)
		}
		// Serialize `lockReleasePointParam`:
		err = enc__.Encode(lockReleasePointParam)
		if err != nil {
			return nil, errors.NewField("lockReleasePointParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "base": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(baseAccount, false, true))
		// Account 2 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 3 "lb_pair": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, false, false))
		// Account 4 "owner": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, false))
		// Account 5 "operator": Read-only, Signer, Required
		// operator
		accounts__.Append(solanago.NewAccountMeta(operatorAccount, false, true))
		// Account 6 "operator_token_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operatorTokenXAccount, false, false))
		// Account 7 "owner_token_x": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerTokenXAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 10 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_position_pda" instruction.
func NewInitializePositionPdaInstruction(
	// Params:
	lowerBinIdParam int32,
	widthParam int32,

	// Accounts:
	payerAccount solanago.PublicKey,
	baseAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePositionPda[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lowerBinIdParam`:
		err = enc__.Encode(lowerBinIdParam)
		if err != nil {
			return nil, errors.NewField("lowerBinIdParam", err)
		}
		// Serialize `widthParam`:
		err = enc__.Encode(widthParam)
		if err != nil {
			return nil, errors.NewField("widthParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "base": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(baseAccount, false, true))
		// Account 2 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 3 "lb_pair": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, false, false))
		// Account 4 "owner": Read-only, Signer, Required
		// owner
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 6 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 7 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_preset_parameter" instruction.
func NewInitializePresetParameterInstruction(
	// Params:
	ixParam InitPresetParametersIx,

	// Accounts:
	presetParameterAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePresetParameter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `ixParam`:
		err = enc__.Encode(ixParam)
		if err != nil {
			return nil, errors.NewField("ixParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "preset_parameter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(presetParameterAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_preset_parameter2" instruction.
func NewInitializePresetParameter2Instruction(
	// Params:
	ixParam InitPresetParameters2Ix,

	// Accounts:
	presetParameterAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePresetParameter2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `ixParam`:
		err = enc__.Encode(ixParam)
		if err != nil {
			return nil, errors.NewField("ixParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "preset_parameter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(presetParameterAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_reward" instruction.
func NewInitializeRewardInstruction(
	// Params:
	rewardIndexParam uint64,
	rewardDurationParam uint64,
	funderParam solanago.PublicKey,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	rewardVaultAccount solanago.PublicKey,
	rewardMintAccount solanago.PublicKey,
	tokenBadgeAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeReward[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `rewardDurationParam`:
		err = enc__.Encode(rewardDurationParam)
		if err != nil {
			return nil, errors.NewField("rewardDurationParam", err)
		}
		// Serialize `funderParam`:
		err = enc__.Encode(funderParam)
		if err != nil {
			return nil, errors.NewField("funderParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "reward_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardVaultAccount, true, false))
		// Account 2 "reward_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardMintAccount, false, false))
		// Account 3 "token_badge": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeAccount, false, false))
		// Account 4 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 5 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_token_badge" instruction.
func NewInitializeTokenBadgeInstruction(
	tokenMintAccount solanago.PublicKey,
	tokenBadgeAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 1 "token_badge": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeAccount, true, false))
		// Account 2 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "migrate_bin_array" instruction.
func NewMigrateBinArrayInstruction(
	lbPairAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "migrate_position" instruction.
func NewMigratePositionInstruction(
	positionV2Account solanago.PublicKey,
	positionV1Account solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position_v2": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionV2Account, true, true))
		// Account 1 "position_v1": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionV1Account, true, false))
		// Account 2 "lb_pair": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, false, false))
		// Account 3 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 4 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 5 "owner": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, true, true))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "rebalance_liquidity" instruction.
func NewRebalanceLiquidityInstruction(
	// Params:
	paramsParam RebalanceLiquidityParams,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	rentPayerAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RebalanceLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 10 "rent_payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentPayerAccount, true, true))
		// Account 11 "token_x_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 12 "token_y_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 13 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 14 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 15 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 16 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_all_liquidity" instruction.
func NewRemoveAllLiquidityInstruction(
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 10 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 11 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 12 "token_x_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 13 "token_y_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "remove_liquidity" instruction.
func NewRemoveLiquidityInstruction(
	// Params:
	binLiquidityRemovalParam []BinLiquidityReduction,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `binLiquidityRemovalParam`:
		err = enc__.Encode(binLiquidityRemovalParam)
		if err != nil {
			return nil, errors.NewField("binLiquidityRemovalParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 10 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 11 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 12 "token_x_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 13 "token_y_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_liquidity2" instruction.
func NewRemoveLiquidity2Instruction(
	// Params:
	binLiquidityRemovalParam []BinLiquidityReduction,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveLiquidity2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `binLiquidityRemovalParam`:
		err = enc__.Encode(binLiquidityRemovalParam)
		if err != nil {
			return nil, errors.NewField("binLiquidityRemovalParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 10 "token_x_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 11 "token_y_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 12 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 13 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 14 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_liquidity_by_range" instruction.
func NewRemoveLiquidityByRangeInstruction(
	// Params:
	fromBinIdParam int32,
	toBinIdParam int32,
	bpsToRemoveParam uint16,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveLiquidityByRange[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `fromBinIdParam`:
		err = enc__.Encode(fromBinIdParam)
		if err != nil {
			return nil, errors.NewField("fromBinIdParam", err)
		}
		// Serialize `toBinIdParam`:
		err = enc__.Encode(toBinIdParam)
		if err != nil {
			return nil, errors.NewField("toBinIdParam", err)
		}
		// Serialize `bpsToRemoveParam`:
		err = enc__.Encode(bpsToRemoveParam)
		if err != nil {
			return nil, errors.NewField("bpsToRemoveParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 10 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 11 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 12 "token_x_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 13 "token_y_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_liquidity_by_range2" instruction.
func NewRemoveLiquidityByRange2Instruction(
	// Params:
	fromBinIdParam int32,
	toBinIdParam int32,
	bpsToRemoveParam uint16,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	userTokenXAccount solanago.PublicKey,
	userTokenYAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveLiquidityByRange2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `fromBinIdParam`:
		err = enc__.Encode(fromBinIdParam)
		if err != nil {
			return nil, errors.NewField("fromBinIdParam", err)
		}
		// Serialize `toBinIdParam`:
		err = enc__.Encode(toBinIdParam)
		if err != nil {
			return nil, errors.NewField("toBinIdParam", err)
		}
		// Serialize `bpsToRemoveParam`:
		err = enc__.Encode(bpsToRemoveParam)
		if err != nil {
			return nil, errors.NewField("bpsToRemoveParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_bitmap_extension": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, true, false))
		// Account 3 "user_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenXAccount, true, false))
		// Account 4 "user_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenYAccount, true, false))
		// Account 5 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 6 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 7 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 8 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 9 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 10 "token_x_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 11 "token_y_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 12 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 13 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 14 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_activation_point" instruction.
func NewSetActivationPointInstruction(
	// Params:
	activationPointParam uint64,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetActivationPoint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `activationPointParam`:
		err = enc__.Encode(activationPointParam)
		if err != nil {
			return nil, errors.NewField("activationPointParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_pair_status" instruction.
func NewSetPairStatusInstruction(
	// Params:
	statusParam uint8,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPairStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_pair_status_permissionless" instruction.
func NewSetPairStatusPermissionlessInstruction(
	// Params:
	statusParam uint8,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	creatorAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPairStatusPermissionless[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "creator": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_pre_activation_duration" instruction.
func NewSetPreActivationDurationInstruction(
	// Params:
	preActivationDurationParam uint64,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	creatorAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPreActivationDuration[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `preActivationDurationParam`:
		err = enc__.Encode(preActivationDurationParam)
		if err != nil {
			return nil, errors.NewField("preActivationDurationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "creator": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_pre_activation_swap_address" instruction.
func NewSetPreActivationSwapAddressInstruction(
	// Params:
	preActivationSwapAddressParam solanago.PublicKey,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	creatorAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPreActivationSwapAddress[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `preActivationSwapAddressParam`:
		err = enc__.Encode(preActivationSwapAddressParam)
		if err != nil {
			return nil, errors.NewField("preActivationSwapAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "creator": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap" instruction.
func NewSwapInstruction(
	// Params:
	amountInParam uint64,
	minAmountOutParam uint64,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	userTokenInAccount solanago.PublicKey,
	userTokenOutAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	hostFeeInAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Swap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountInParam`:
		err = enc__.Encode(amountInParam)
		if err != nil {
			return nil, errors.NewField("amountInParam", err)
		}
		// Serialize `minAmountOutParam`:
		err = enc__.Encode(minAmountOutParam)
		if err != nil {
			return nil, errors.NewField("minAmountOutParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, false, false))
		// Account 2 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 3 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 4 "user_token_in": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenInAccount, true, false))
		// Account 5 "user_token_out": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenOutAccount, true, false))
		// Account 6 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 7 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 8 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 9 "host_fee_in": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(hostFeeInAccount, true, false))
		// Account 10 "user": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 11 "token_x_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 12 "token_y_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 13 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 14 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap2" instruction.
func NewSwap2Instruction(
	// Params:
	amountInParam uint64,
	minAmountOutParam uint64,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	userTokenInAccount solanago.PublicKey,
	userTokenOutAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	hostFeeInAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Swap2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountInParam`:
		err = enc__.Encode(amountInParam)
		if err != nil {
			return nil, errors.NewField("amountInParam", err)
		}
		// Serialize `minAmountOutParam`:
		err = enc__.Encode(minAmountOutParam)
		if err != nil {
			return nil, errors.NewField("minAmountOutParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, false, false))
		// Account 2 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 3 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 4 "user_token_in": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenInAccount, true, false))
		// Account 5 "user_token_out": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenOutAccount, true, false))
		// Account 6 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 7 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 8 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 9 "host_fee_in": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(hostFeeInAccount, true, false))
		// Account 10 "user": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 11 "token_x_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 12 "token_y_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 13 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap_exact_out" instruction.
func NewSwapExactOutInstruction(
	// Params:
	maxInAmountParam uint64,
	outAmountParam uint64,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	userTokenInAccount solanago.PublicKey,
	userTokenOutAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	hostFeeInAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SwapExactOut[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxInAmountParam`:
		err = enc__.Encode(maxInAmountParam)
		if err != nil {
			return nil, errors.NewField("maxInAmountParam", err)
		}
		// Serialize `outAmountParam`:
		err = enc__.Encode(outAmountParam)
		if err != nil {
			return nil, errors.NewField("outAmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, false, false))
		// Account 2 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 3 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 4 "user_token_in": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenInAccount, true, false))
		// Account 5 "user_token_out": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenOutAccount, true, false))
		// Account 6 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 7 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 8 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 9 "host_fee_in": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(hostFeeInAccount, true, false))
		// Account 10 "user": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 11 "token_x_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 12 "token_y_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 13 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 14 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap_exact_out2" instruction.
func NewSwapExactOut2Instruction(
	// Params:
	maxInAmountParam uint64,
	outAmountParam uint64,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	userTokenInAccount solanago.PublicKey,
	userTokenOutAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	hostFeeInAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SwapExactOut2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxInAmountParam`:
		err = enc__.Encode(maxInAmountParam)
		if err != nil {
			return nil, errors.NewField("maxInAmountParam", err)
		}
		// Serialize `outAmountParam`:
		err = enc__.Encode(outAmountParam)
		if err != nil {
			return nil, errors.NewField("outAmountParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, false, false))
		// Account 2 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 3 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 4 "user_token_in": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenInAccount, true, false))
		// Account 5 "user_token_out": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenOutAccount, true, false))
		// Account 6 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 7 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 8 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 9 "host_fee_in": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(hostFeeInAccount, true, false))
		// Account 10 "user": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 11 "token_x_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 12 "token_y_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 13 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap_with_price_impact" instruction.
func NewSwapWithPriceImpactInstruction(
	// Params:
	amountInParam uint64,
	activeIdParam *int32,
	maxPriceImpactBpsParam uint16,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	userTokenInAccount solanago.PublicKey,
	userTokenOutAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	hostFeeInAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SwapWithPriceImpact[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountInParam`:
		err = enc__.Encode(amountInParam)
		if err != nil {
			return nil, errors.NewField("amountInParam", err)
		}
		// Serialize `activeIdParam` (optional):
		{
			if activeIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("activeIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("activeIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(activeIdParam)
				if err != nil {
					return nil, errors.NewField("activeIdParam", err)
				}
			}
		}
		// Serialize `maxPriceImpactBpsParam`:
		err = enc__.Encode(maxPriceImpactBpsParam)
		if err != nil {
			return nil, errors.NewField("maxPriceImpactBpsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, false, false))
		// Account 2 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 3 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 4 "user_token_in": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenInAccount, true, false))
		// Account 5 "user_token_out": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenOutAccount, true, false))
		// Account 6 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 7 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 8 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 9 "host_fee_in": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(hostFeeInAccount, true, false))
		// Account 10 "user": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 11 "token_x_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 12 "token_y_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 13 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 14 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap_with_price_impact2" instruction.
func NewSwapWithPriceImpact2Instruction(
	// Params:
	amountInParam uint64,
	activeIdParam *int32,
	maxPriceImpactBpsParam uint16,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	binArrayBitmapExtensionAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	userTokenInAccount solanago.PublicKey,
	userTokenOutAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	hostFeeInAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SwapWithPriceImpact2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountInParam`:
		err = enc__.Encode(amountInParam)
		if err != nil {
			return nil, errors.NewField("amountInParam", err)
		}
		// Serialize `activeIdParam` (optional):
		{
			if activeIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("activeIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("activeIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(activeIdParam)
				if err != nil {
					return nil, errors.NewField("activeIdParam", err)
				}
			}
		}
		// Serialize `maxPriceImpactBpsParam`:
		err = enc__.Encode(maxPriceImpactBpsParam)
		if err != nil {
			return nil, errors.NewField("maxPriceImpactBpsParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "bin_array_bitmap_extension": Read-only, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(binArrayBitmapExtensionAccount, false, false))
		// Account 2 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 3 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 4 "user_token_in": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenInAccount, true, false))
		// Account 5 "user_token_out": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenOutAccount, true, false))
		// Account 6 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 7 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 8 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
		// Account 9 "host_fee_in": Writable, Non-signer, Optional
		accounts__.Append(solanago.NewAccountMeta(hostFeeInAccount, true, false))
		// Account 10 "user": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 11 "token_x_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 12 "token_y_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 13 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 14 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 15 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_base_fee_parameters" instruction.
func NewUpdateBaseFeeParametersInstruction(
	// Params:
	feeParameterParam BaseFeeParameter,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateBaseFeeParameters[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feeParameterParam`:
		err = enc__.Encode(feeParameterParam)
		if err != nil {
			return nil, errors.NewField("feeParameterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 2 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_dynamic_fee_parameters" instruction.
func NewUpdateDynamicFeeParametersInstruction(
	// Params:
	feeParameterParam DynamicFeeParameter,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDynamicFeeParameters[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feeParameterParam`:
		err = enc__.Encode(feeParameterParam)
		if err != nil {
			return nil, errors.NewField("feeParameterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 2 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_fees_and_reward2" instruction.
func NewUpdateFeesAndReward2Instruction(
	// Params:
	minBinIdParam int32,
	maxBinIdParam int32,

	// Accounts:
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateFeesAndReward2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `minBinIdParam`:
		err = enc__.Encode(minBinIdParam)
		if err != nil {
			return nil, errors.NewField("minBinIdParam", err)
		}
		// Serialize `maxBinIdParam`:
		err = enc__.Encode(maxBinIdParam)
		if err != nil {
			return nil, errors.NewField("maxBinIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_fees_and_rewards" instruction.
func NewUpdateFeesAndRewardsInstruction(
	positionAccount solanago.PublicKey,
	lbPairAccount solanago.PublicKey,
	binArrayLowerAccount solanago.PublicKey,
	binArrayUpperAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 2 "bin_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayLowerAccount, true, false))
		// Account 3 "bin_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayUpperAccount, true, false))
		// Account 4 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_position_operator" instruction.
func NewUpdatePositionOperatorInstruction(
	// Params:
	operatorParam solanago.PublicKey,

	// Accounts:
	positionAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePositionOperator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `operatorParam`:
		err = enc__.Encode(operatorParam)
		if err != nil {
			return nil, errors.NewField("operatorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 1 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 2 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_reward_duration" instruction.
func NewUpdateRewardDurationInstruction(
	// Params:
	rewardIndexParam uint64,
	newDurationParam uint64,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	binArrayAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateRewardDuration[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `newDurationParam`:
		err = enc__.Encode(newDurationParam)
		if err != nil {
			return nil, errors.NewField("newDurationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 2 "bin_array": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayAccount, true, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_reward_funder" instruction.
func NewUpdateRewardFunderInstruction(
	// Params:
	rewardIndexParam uint64,
	newFunderParam solanago.PublicKey,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateRewardFunder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `newFunderParam`:
		err = enc__.Encode(newFunderParam)
		if err != nil {
			return nil, errors.NewField("newFunderParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 2 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_ineligible_reward" instruction.
func NewWithdrawIneligibleRewardInstruction(
	// Params:
	rewardIndexParam uint64,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	rewardVaultAccount solanago.PublicKey,
	rewardMintAccount solanago.PublicKey,
	funderTokenAccountAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	binArrayAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawIneligibleReward[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "reward_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardVaultAccount, true, false))
		// Account 2 "reward_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardMintAccount, false, false))
		// Account 3 "funder_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderTokenAccountAccount, true, false))
		// Account 4 "funder": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, false, true))
		// Account 5 "bin_array": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(binArrayAccount, true, false))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_protocol_fee" instruction.
func NewWithdrawProtocolFeeInstruction(
	// Params:
	maxAmountXParam uint64,
	maxAmountYParam uint64,
	remainingAccountsInfoParam RemainingAccountsInfo,

	// Accounts:
	lbPairAccount solanago.PublicKey,
	reserveXAccount solanago.PublicKey,
	reserveYAccount solanago.PublicKey,
	tokenXMintAccount solanago.PublicKey,
	tokenYMintAccount solanago.PublicKey,
	receiverTokenXAccount solanago.PublicKey,
	receiverTokenYAccount solanago.PublicKey,
	claimFeeOperatorAccount solanago.PublicKey,
	operatorAccount solanago.PublicKey,
	tokenXProgramAccount solanago.PublicKey,
	tokenYProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawProtocolFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxAmountXParam`:
		err = enc__.Encode(maxAmountXParam)
		if err != nil {
			return nil, errors.NewField("maxAmountXParam", err)
		}
		// Serialize `maxAmountYParam`:
		err = enc__.Encode(maxAmountYParam)
		if err != nil {
			return nil, errors.NewField("maxAmountYParam", err)
		}
		// Serialize `remainingAccountsInfoParam`:
		err = enc__.Encode(remainingAccountsInfoParam)
		if err != nil {
			return nil, errors.NewField("remainingAccountsInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "lb_pair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lbPairAccount, true, false))
		// Account 1 "reserve_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveXAccount, true, false))
		// Account 2 "reserve_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveYAccount, true, false))
		// Account 3 "token_x_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXMintAccount, false, false))
		// Account 4 "token_y_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYMintAccount, false, false))
		// Account 5 "receiver_token_x": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverTokenXAccount, true, false))
		// Account 6 "receiver_token_y": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverTokenYAccount, true, false))
		// Account 7 "claim_fee_operator": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(claimFeeOperatorAccount, false, false))
		// Account 8 "operator": Read-only, Signer, Required
		// operator
		accounts__.Append(solanago.NewAccountMeta(operatorAccount, false, true))
		// Account 9 "token_x_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenXProgramAccount, false, false))
		// Account 10 "token_y_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenYProgramAccount, false, false))
		// Account 11 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AddLiquidityInstruction struct {
	LiquidityParameter LiquidityParameter `json:"liquidity_parameter"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	BinArrayLower                   solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable           bool               `json:"bin_array_lower_writable"`
	BinArrayUpper                   solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable           bool               `json:"bin_array_upper_writable"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *AddLiquidityInstruction) GetDiscriminator() []byte {
	return Instruction_AddLiquidity[:]
}

func (obj *AddLiquidityInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LiquidityParameter`:
	err = decoder.Decode(&obj.LiquidityParameter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidityInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLiquidityInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLiquidityInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *AddLiquidityInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidityInstruction: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidityInstruction(buf []byte) (*AddLiquidityInstruction, error) {
	obj := new(AddLiquidityInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquidity2Instruction struct {
	LiquidityParameter    LiquidityParameter    `json:"liquidity_parameter"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *AddLiquidity2Instruction) GetDiscriminator() []byte {
	return Instruction_AddLiquidity2[:]
}

func (obj *AddLiquidity2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LiquidityParameter`:
	err = decoder.Decode(&obj.LiquidityParameter)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidity2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLiquidity2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 14 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 14, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLiquidity2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *AddLiquidity2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidity2Instruction: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidity2Instruction(buf []byte) (*AddLiquidity2Instruction, error) {
	obj := new(AddLiquidity2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquidityByStrategyInstruction struct {
	LiquidityParameter LiquidityParameterByStrategy `json:"liquidity_parameter"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	BinArrayLower                   solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable           bool               `json:"bin_array_lower_writable"`
	BinArrayUpper                   solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable           bool               `json:"bin_array_upper_writable"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *AddLiquidityByStrategyInstruction) GetDiscriminator() []byte {
	return Instruction_AddLiquidityByStrategy[:]
}

func (obj *AddLiquidityByStrategyInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LiquidityParameter`:
	err = decoder.Decode(&obj.LiquidityParameter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidityByStrategyInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLiquidityByStrategyInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLiquidityByStrategyInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *AddLiquidityByStrategyInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidityByStrategyInstruction: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidityByStrategyInstruction(buf []byte) (*AddLiquidityByStrategyInstruction, error) {
	obj := new(AddLiquidityByStrategyInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquidityByStrategy2Instruction struct {
	LiquidityParameter    LiquidityParameterByStrategy `json:"liquidity_parameter"`
	RemainingAccountsInfo RemainingAccountsInfo        `json:"remaining_accounts_info"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *AddLiquidityByStrategy2Instruction) GetDiscriminator() []byte {
	return Instruction_AddLiquidityByStrategy2[:]
}

func (obj *AddLiquidityByStrategy2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LiquidityParameter`:
	err = decoder.Decode(&obj.LiquidityParameter)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidityByStrategy2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLiquidityByStrategy2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 14 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 14, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLiquidityByStrategy2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *AddLiquidityByStrategy2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidityByStrategy2Instruction: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidityByStrategy2Instruction(buf []byte) (*AddLiquidityByStrategy2Instruction, error) {
	obj := new(AddLiquidityByStrategy2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquidityByStrategyOneSideInstruction struct {
	LiquidityParameter LiquidityParameterByStrategyOneSide `json:"liquidity_parameter"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserToken                       solanago.PublicKey `json:"user_token"`
	UserTokenWritable               bool               `json:"user_token_writable"`
	Reserve                         solanago.PublicKey `json:"reserve"`
	ReserveWritable                 bool               `json:"reserve_writable"`
	TokenMint                       solanago.PublicKey `json:"token_mint"`
	BinArrayLower                   solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable           bool               `json:"bin_array_lower_writable"`
	BinArrayUpper                   solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable           bool               `json:"bin_array_upper_writable"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenProgram                    solanago.PublicKey `json:"token_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *AddLiquidityByStrategyOneSideInstruction) GetDiscriminator() []byte {
	return Instruction_AddLiquidityByStrategyOneSide[:]
}

func (obj *AddLiquidityByStrategyOneSideInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LiquidityParameter`:
	err = decoder.Decode(&obj.LiquidityParameter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidityByStrategyOneSideInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token", err)
	}
	indices = append(indices, index)
	// Decode from reserve account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve", err)
	}
	indices = append(indices, index)
	// Decode from token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLiquidityByStrategyOneSideInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 12 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 12, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token", len(accountKeys)-1)
	}
	obj.UserToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve", len(accountKeys)-1)
	}
	obj.Reserve = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint", len(accountKeys)-1)
	}
	obj.TokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLiquidityByStrategyOneSideInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserToken)
	keys = append(keys, obj.Reserve)
	keys = append(keys, obj.TokenMint)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *AddLiquidityByStrategyOneSideInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidityByStrategyOneSideInstruction: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidityByStrategyOneSideInstruction(buf []byte) (*AddLiquidityByStrategyOneSideInstruction, error) {
	obj := new(AddLiquidityByStrategyOneSideInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquidityByWeightInstruction struct {
	LiquidityParameter LiquidityParameterByWeight `json:"liquidity_parameter"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	BinArrayLower                   solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable           bool               `json:"bin_array_lower_writable"`
	BinArrayUpper                   solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable           bool               `json:"bin_array_upper_writable"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *AddLiquidityByWeightInstruction) GetDiscriminator() []byte {
	return Instruction_AddLiquidityByWeight[:]
}

func (obj *AddLiquidityByWeightInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LiquidityParameter`:
	err = decoder.Decode(&obj.LiquidityParameter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidityByWeightInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLiquidityByWeightInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLiquidityByWeightInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *AddLiquidityByWeightInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidityByWeightInstruction: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidityByWeightInstruction(buf []byte) (*AddLiquidityByWeightInstruction, error) {
	obj := new(AddLiquidityByWeightInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquidityOneSideInstruction struct {
	LiquidityParameter LiquidityOneSideParameter `json:"liquidity_parameter"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserToken                       solanago.PublicKey `json:"user_token"`
	UserTokenWritable               bool               `json:"user_token_writable"`
	Reserve                         solanago.PublicKey `json:"reserve"`
	ReserveWritable                 bool               `json:"reserve_writable"`
	TokenMint                       solanago.PublicKey `json:"token_mint"`
	BinArrayLower                   solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable           bool               `json:"bin_array_lower_writable"`
	BinArrayUpper                   solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable           bool               `json:"bin_array_upper_writable"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenProgram                    solanago.PublicKey `json:"token_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *AddLiquidityOneSideInstruction) GetDiscriminator() []byte {
	return Instruction_AddLiquidityOneSide[:]
}

func (obj *AddLiquidityOneSideInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LiquidityParameter`:
	err = decoder.Decode(&obj.LiquidityParameter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidityOneSideInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token", err)
	}
	indices = append(indices, index)
	// Decode from reserve account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve", err)
	}
	indices = append(indices, index)
	// Decode from token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLiquidityOneSideInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 12 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 12, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token", len(accountKeys)-1)
	}
	obj.UserToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve", len(accountKeys)-1)
	}
	obj.Reserve = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint", len(accountKeys)-1)
	}
	obj.TokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLiquidityOneSideInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserToken)
	keys = append(keys, obj.Reserve)
	keys = append(keys, obj.TokenMint)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *AddLiquidityOneSideInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidityOneSideInstruction: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidityOneSideInstruction(buf []byte) (*AddLiquidityOneSideInstruction, error) {
	obj := new(AddLiquidityOneSideInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquidityOneSidePreciseInstruction struct {
	Parameter AddLiquiditySingleSidePreciseParameter `json:"parameter"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserToken                       solanago.PublicKey `json:"user_token"`
	UserTokenWritable               bool               `json:"user_token_writable"`
	Reserve                         solanago.PublicKey `json:"reserve"`
	ReserveWritable                 bool               `json:"reserve_writable"`
	TokenMint                       solanago.PublicKey `json:"token_mint"`
	BinArrayLower                   solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable           bool               `json:"bin_array_lower_writable"`
	BinArrayUpper                   solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable           bool               `json:"bin_array_upper_writable"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenProgram                    solanago.PublicKey `json:"token_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *AddLiquidityOneSidePreciseInstruction) GetDiscriminator() []byte {
	return Instruction_AddLiquidityOneSidePrecise[:]
}

func (obj *AddLiquidityOneSidePreciseInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Parameter`:
	err = decoder.Decode(&obj.Parameter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidityOneSidePreciseInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token", err)
	}
	indices = append(indices, index)
	// Decode from reserve account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve", err)
	}
	indices = append(indices, index)
	// Decode from token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLiquidityOneSidePreciseInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 12 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 12, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token", len(accountKeys)-1)
	}
	obj.UserToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve", len(accountKeys)-1)
	}
	obj.Reserve = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint", len(accountKeys)-1)
	}
	obj.TokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLiquidityOneSidePreciseInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserToken)
	keys = append(keys, obj.Reserve)
	keys = append(keys, obj.TokenMint)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *AddLiquidityOneSidePreciseInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidityOneSidePreciseInstruction: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidityOneSidePreciseInstruction(buf []byte) (*AddLiquidityOneSidePreciseInstruction, error) {
	obj := new(AddLiquidityOneSidePreciseInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquidityOneSidePrecise2Instruction struct {
	LiquidityParameter    AddLiquiditySingleSidePreciseParameter2 `json:"liquidity_parameter"`
	RemainingAccountsInfo RemainingAccountsInfo                   `json:"remaining_accounts_info"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserToken                       solanago.PublicKey `json:"user_token"`
	UserTokenWritable               bool               `json:"user_token_writable"`
	Reserve                         solanago.PublicKey `json:"reserve"`
	ReserveWritable                 bool               `json:"reserve_writable"`
	TokenMint                       solanago.PublicKey `json:"token_mint"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenProgram                    solanago.PublicKey `json:"token_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *AddLiquidityOneSidePrecise2Instruction) GetDiscriminator() []byte {
	return Instruction_AddLiquidityOneSidePrecise2[:]
}

func (obj *AddLiquidityOneSidePrecise2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LiquidityParameter`:
	err = decoder.Decode(&obj.LiquidityParameter)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidityOneSidePrecise2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token", err)
	}
	indices = append(indices, index)
	// Decode from reserve account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve", err)
	}
	indices = append(indices, index)
	// Decode from token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLiquidityOneSidePrecise2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token", len(accountKeys)-1)
	}
	obj.UserToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve", len(accountKeys)-1)
	}
	obj.Reserve = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint", len(accountKeys)-1)
	}
	obj.TokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLiquidityOneSidePrecise2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserToken)
	keys = append(keys, obj.Reserve)
	keys = append(keys, obj.TokenMint)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *AddLiquidityOneSidePrecise2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidityOneSidePrecise2Instruction: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidityOneSidePrecise2Instruction(buf []byte) (*AddLiquidityOneSidePrecise2Instruction, error) {
	obj := new(AddLiquidityOneSidePrecise2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClaimFeeInstruction struct {

	// Accounts:
	LbPair                solanago.PublicKey `json:"lb_pair"`
	LbPairWritable        bool               `json:"lb_pair_writable"`
	Position              solanago.PublicKey `json:"position"`
	PositionWritable      bool               `json:"position_writable"`
	BinArrayLower         solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable bool               `json:"bin_array_lower_writable"`
	BinArrayUpper         solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable bool               `json:"bin_array_upper_writable"`
	Sender                solanago.PublicKey `json:"sender"`
	SenderSigner          bool               `json:"sender_signer"`
	ReserveX              solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable      bool               `json:"reserve_x_writable"`
	ReserveY              solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable      bool               `json:"reserve_y_writable"`
	UserTokenX            solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable    bool               `json:"user_token_x_writable"`
	UserTokenY            solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable    bool               `json:"user_token_y_writable"`
	TokenXMint            solanago.PublicKey `json:"token_x_mint"`
	TokenYMint            solanago.PublicKey `json:"token_y_mint"`
	TokenProgram          solanago.PublicKey `json:"token_program"`
	EventAuthority        solanago.PublicKey `json:"event_authority"`
	Program               solanago.PublicKey `json:"program"`
}

func (obj *ClaimFeeInstruction) GetDiscriminator() []byte {
	return Instruction_ClaimFee[:]
}

func (obj *ClaimFeeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *ClaimFeeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClaimFeeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 14 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 14, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClaimFeeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *ClaimFeeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClaimFeeInstruction: %w", err)
	}
	return nil
}

func UnmarshalClaimFeeInstruction(buf []byte) (*ClaimFeeInstruction, error) {
	obj := new(ClaimFeeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClaimFee2Instruction struct {
	MinBinId              int32                 `json:"min_bin_id"`
	MaxBinId              int32                 `json:"max_bin_id"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	LbPair             solanago.PublicKey `json:"lb_pair"`
	LbPairWritable     bool               `json:"lb_pair_writable"`
	Position           solanago.PublicKey `json:"position"`
	PositionWritable   bool               `json:"position_writable"`
	Sender             solanago.PublicKey `json:"sender"`
	SenderSigner       bool               `json:"sender_signer"`
	ReserveX           solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable   bool               `json:"reserve_x_writable"`
	ReserveY           solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable   bool               `json:"reserve_y_writable"`
	UserTokenX         solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable bool               `json:"user_token_x_writable"`
	UserTokenY         solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable bool               `json:"user_token_y_writable"`
	TokenXMint         solanago.PublicKey `json:"token_x_mint"`
	TokenYMint         solanago.PublicKey `json:"token_y_mint"`
	TokenProgramX      solanago.PublicKey `json:"token_program_x"`
	TokenProgramY      solanago.PublicKey `json:"token_program_y"`
	MemoProgram        solanago.PublicKey `json:"memo_program"`
	EventAuthority     solanago.PublicKey `json:"event_authority"`
	Program            solanago.PublicKey `json:"program"`
}

func (obj *ClaimFee2Instruction) GetDiscriminator() []byte {
	return Instruction_ClaimFee2[:]
}

func (obj *ClaimFee2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `MinBinId`:
	err = decoder.Decode(&obj.MinBinId)
	if err != nil {
		return err
	}
	// Deserialize `MaxBinId`:
	err = decoder.Decode(&obj.MaxBinId)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ClaimFee2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_program_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program_x", err)
	}
	indices = append(indices, index)
	// Decode from token_program_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program_y", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClaimFee2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 14 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 14, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program_x", len(accountKeys)-1)
	}
	obj.TokenProgramX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program_y", len(accountKeys)-1)
	}
	obj.TokenProgramY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClaimFee2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.TokenProgramX)
	keys = append(keys, obj.TokenProgramY)
	keys = append(keys, obj.MemoProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *ClaimFee2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClaimFee2Instruction: %w", err)
	}
	return nil
}

func UnmarshalClaimFee2Instruction(buf []byte) (*ClaimFee2Instruction, error) {
	obj := new(ClaimFee2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClaimRewardInstruction struct {
	RewardIndex uint64 `json:"reward_index"`

	// Accounts:
	LbPair                   solanago.PublicKey `json:"lb_pair"`
	LbPairWritable           bool               `json:"lb_pair_writable"`
	Position                 solanago.PublicKey `json:"position"`
	PositionWritable         bool               `json:"position_writable"`
	BinArrayLower            solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable    bool               `json:"bin_array_lower_writable"`
	BinArrayUpper            solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable    bool               `json:"bin_array_upper_writable"`
	Sender                   solanago.PublicKey `json:"sender"`
	SenderSigner             bool               `json:"sender_signer"`
	RewardVault              solanago.PublicKey `json:"reward_vault"`
	RewardVaultWritable      bool               `json:"reward_vault_writable"`
	RewardMint               solanago.PublicKey `json:"reward_mint"`
	UserTokenAccount         solanago.PublicKey `json:"user_token_account"`
	UserTokenAccountWritable bool               `json:"user_token_account_writable"`
	TokenProgram             solanago.PublicKey `json:"token_program"`
	EventAuthority           solanago.PublicKey `json:"event_authority"`
	Program                  solanago.PublicKey `json:"program"`
}

func (obj *ClaimRewardInstruction) GetDiscriminator() []byte {
	return Instruction_ClaimReward[:]
}

func (obj *ClaimRewardInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `RewardIndex`:
	err = decoder.Decode(&obj.RewardIndex)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ClaimRewardInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from reward_vault account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_vault", err)
	}
	indices = append(indices, index)
	// Decode from reward_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_mint", err)
	}
	indices = append(indices, index)
	// Decode from user_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_account", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClaimRewardInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 11 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 11, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_vault account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_vault", len(accountKeys)-1)
	}
	obj.RewardVault = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_mint", len(accountKeys)-1)
	}
	obj.RewardMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_account", len(accountKeys)-1)
	}
	obj.UserTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClaimRewardInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.RewardVault)
	keys = append(keys, obj.RewardMint)
	keys = append(keys, obj.UserTokenAccount)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *ClaimRewardInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClaimRewardInstruction: %w", err)
	}
	return nil
}

func UnmarshalClaimRewardInstruction(buf []byte) (*ClaimRewardInstruction, error) {
	obj := new(ClaimRewardInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClaimReward2Instruction struct {
	RewardIndex           uint64                `json:"reward_index"`
	MinBinId              int32                 `json:"min_bin_id"`
	MaxBinId              int32                 `json:"max_bin_id"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	LbPair                   solanago.PublicKey `json:"lb_pair"`
	LbPairWritable           bool               `json:"lb_pair_writable"`
	Position                 solanago.PublicKey `json:"position"`
	PositionWritable         bool               `json:"position_writable"`
	Sender                   solanago.PublicKey `json:"sender"`
	SenderSigner             bool               `json:"sender_signer"`
	RewardVault              solanago.PublicKey `json:"reward_vault"`
	RewardVaultWritable      bool               `json:"reward_vault_writable"`
	RewardMint               solanago.PublicKey `json:"reward_mint"`
	UserTokenAccount         solanago.PublicKey `json:"user_token_account"`
	UserTokenAccountWritable bool               `json:"user_token_account_writable"`
	TokenProgram             solanago.PublicKey `json:"token_program"`
	MemoProgram              solanago.PublicKey `json:"memo_program"`
	EventAuthority           solanago.PublicKey `json:"event_authority"`
	Program                  solanago.PublicKey `json:"program"`
}

func (obj *ClaimReward2Instruction) GetDiscriminator() []byte {
	return Instruction_ClaimReward2[:]
}

func (obj *ClaimReward2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `RewardIndex`:
	err = decoder.Decode(&obj.RewardIndex)
	if err != nil {
		return err
	}
	// Deserialize `MinBinId`:
	err = decoder.Decode(&obj.MinBinId)
	if err != nil {
		return err
	}
	// Deserialize `MaxBinId`:
	err = decoder.Decode(&obj.MaxBinId)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ClaimReward2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from reward_vault account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_vault", err)
	}
	indices = append(indices, index)
	// Decode from reward_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_mint", err)
	}
	indices = append(indices, index)
	// Decode from user_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_account", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClaimReward2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_vault account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_vault", len(accountKeys)-1)
	}
	obj.RewardVault = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_mint", len(accountKeys)-1)
	}
	obj.RewardMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_account", len(accountKeys)-1)
	}
	obj.UserTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClaimReward2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.RewardVault)
	keys = append(keys, obj.RewardMint)
	keys = append(keys, obj.UserTokenAccount)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.MemoProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *ClaimReward2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClaimReward2Instruction: %w", err)
	}
	return nil
}

func UnmarshalClaimReward2Instruction(buf []byte) (*ClaimReward2Instruction, error) {
	obj := new(ClaimReward2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CloseClaimProtocolFeeOperatorInstruction struct {

	// Accounts:
	ClaimFeeOperator         solanago.PublicKey `json:"claim_fee_operator"`
	ClaimFeeOperatorWritable bool               `json:"claim_fee_operator_writable"`
	RentReceiver             solanago.PublicKey `json:"rent_receiver"`
	RentReceiverWritable     bool               `json:"rent_receiver_writable"`
	Admin                    solanago.PublicKey `json:"admin"`
	AdminSigner              bool               `json:"admin_signer"`
}

func (obj *CloseClaimProtocolFeeOperatorInstruction) GetDiscriminator() []byte {
	return Instruction_CloseClaimProtocolFeeOperator[:]
}

func (obj *CloseClaimProtocolFeeOperatorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *CloseClaimProtocolFeeOperatorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from claim_fee_operator account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "claim_fee_operator", err)
	}
	indices = append(indices, index)
	// Decode from rent_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent_receiver", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CloseClaimProtocolFeeOperatorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set claim_fee_operator account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "claim_fee_operator", len(accountKeys)-1)
	}
	obj.ClaimFeeOperator = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent_receiver", len(accountKeys)-1)
	}
	obj.RentReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CloseClaimProtocolFeeOperatorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.ClaimFeeOperator)
	keys = append(keys, obj.RentReceiver)
	keys = append(keys, obj.Admin)
	return keys
}

func (obj *CloseClaimProtocolFeeOperatorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CloseClaimProtocolFeeOperatorInstruction: %w", err)
	}
	return nil
}

func UnmarshalCloseClaimProtocolFeeOperatorInstruction(buf []byte) (*CloseClaimProtocolFeeOperatorInstruction, error) {
	obj := new(CloseClaimProtocolFeeOperatorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClosePositionInstruction struct {

	// Accounts:
	Position              solanago.PublicKey `json:"position"`
	PositionWritable      bool               `json:"position_writable"`
	LbPair                solanago.PublicKey `json:"lb_pair"`
	LbPairWritable        bool               `json:"lb_pair_writable"`
	BinArrayLower         solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable bool               `json:"bin_array_lower_writable"`
	BinArrayUpper         solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable bool               `json:"bin_array_upper_writable"`
	Sender                solanago.PublicKey `json:"sender"`
	SenderSigner          bool               `json:"sender_signer"`
	RentReceiver          solanago.PublicKey `json:"rent_receiver"`
	RentReceiverWritable  bool               `json:"rent_receiver_writable"`
	EventAuthority        solanago.PublicKey `json:"event_authority"`
	Program               solanago.PublicKey `json:"program"`
}

func (obj *ClosePositionInstruction) GetDiscriminator() []byte {
	return Instruction_ClosePosition[:]
}

func (obj *ClosePositionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *ClosePositionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from rent_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent_receiver", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClosePositionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 8 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 8, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent_receiver", len(accountKeys)-1)
	}
	obj.RentReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClosePositionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.RentReceiver)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *ClosePositionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClosePositionInstruction: %w", err)
	}
	return nil
}

func UnmarshalClosePositionInstruction(buf []byte) (*ClosePositionInstruction, error) {
	obj := new(ClosePositionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClosePosition2Instruction struct {

	// Accounts:
	Position             solanago.PublicKey `json:"position"`
	PositionWritable     bool               `json:"position_writable"`
	Sender               solanago.PublicKey `json:"sender"`
	SenderSigner         bool               `json:"sender_signer"`
	RentReceiver         solanago.PublicKey `json:"rent_receiver"`
	RentReceiverWritable bool               `json:"rent_receiver_writable"`
	EventAuthority       solanago.PublicKey `json:"event_authority"`
	Program              solanago.PublicKey `json:"program"`
}

func (obj *ClosePosition2Instruction) GetDiscriminator() []byte {
	return Instruction_ClosePosition2[:]
}

func (obj *ClosePosition2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *ClosePosition2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from rent_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent_receiver", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClosePosition2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent_receiver", len(accountKeys)-1)
	}
	obj.RentReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClosePosition2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.RentReceiver)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *ClosePosition2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClosePosition2Instruction: %w", err)
	}
	return nil
}

func UnmarshalClosePosition2Instruction(buf []byte) (*ClosePosition2Instruction, error) {
	obj := new(ClosePosition2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClosePositionIfEmptyInstruction struct {

	// Accounts:
	Position             solanago.PublicKey `json:"position"`
	PositionWritable     bool               `json:"position_writable"`
	Sender               solanago.PublicKey `json:"sender"`
	SenderSigner         bool               `json:"sender_signer"`
	RentReceiver         solanago.PublicKey `json:"rent_receiver"`
	RentReceiverWritable bool               `json:"rent_receiver_writable"`
	EventAuthority       solanago.PublicKey `json:"event_authority"`
	Program              solanago.PublicKey `json:"program"`
}

func (obj *ClosePositionIfEmptyInstruction) GetDiscriminator() []byte {
	return Instruction_ClosePositionIfEmpty[:]
}

func (obj *ClosePositionIfEmptyInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *ClosePositionIfEmptyInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from rent_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent_receiver", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClosePositionIfEmptyInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent_receiver", len(accountKeys)-1)
	}
	obj.RentReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClosePositionIfEmptyInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.RentReceiver)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *ClosePositionIfEmptyInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClosePositionIfEmptyInstruction: %w", err)
	}
	return nil
}

func UnmarshalClosePositionIfEmptyInstruction(buf []byte) (*ClosePositionIfEmptyInstruction, error) {
	obj := new(ClosePositionIfEmptyInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClosePresetParameterInstruction struct {

	// Accounts:
	PresetParameter         solanago.PublicKey `json:"preset_parameter"`
	PresetParameterWritable bool               `json:"preset_parameter_writable"`
	Admin                   solanago.PublicKey `json:"admin"`
	AdminWritable           bool               `json:"admin_writable"`
	AdminSigner             bool               `json:"admin_signer"`
	RentReceiver            solanago.PublicKey `json:"rent_receiver"`
	RentReceiverWritable    bool               `json:"rent_receiver_writable"`
}

func (obj *ClosePresetParameterInstruction) GetDiscriminator() []byte {
	return Instruction_ClosePresetParameter[:]
}

func (obj *ClosePresetParameterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *ClosePresetParameterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from preset_parameter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "preset_parameter", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from rent_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent_receiver", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClosePresetParameterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set preset_parameter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "preset_parameter", len(accountKeys)-1)
	}
	obj.PresetParameter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent_receiver", len(accountKeys)-1)
	}
	obj.RentReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClosePresetParameterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.PresetParameter)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.RentReceiver)
	return keys
}

func (obj *ClosePresetParameterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClosePresetParameterInstruction: %w", err)
	}
	return nil
}

func UnmarshalClosePresetParameterInstruction(buf []byte) (*ClosePresetParameterInstruction, error) {
	obj := new(ClosePresetParameterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClosePresetParameter2Instruction struct {

	// Accounts:
	PresetParameter         solanago.PublicKey `json:"preset_parameter"`
	PresetParameterWritable bool               `json:"preset_parameter_writable"`
	Admin                   solanago.PublicKey `json:"admin"`
	AdminWritable           bool               `json:"admin_writable"`
	AdminSigner             bool               `json:"admin_signer"`
	RentReceiver            solanago.PublicKey `json:"rent_receiver"`
	RentReceiverWritable    bool               `json:"rent_receiver_writable"`
}

func (obj *ClosePresetParameter2Instruction) GetDiscriminator() []byte {
	return Instruction_ClosePresetParameter2[:]
}

func (obj *ClosePresetParameter2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *ClosePresetParameter2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from preset_parameter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "preset_parameter", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from rent_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent_receiver", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClosePresetParameter2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set preset_parameter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "preset_parameter", len(accountKeys)-1)
	}
	obj.PresetParameter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent_receiver", len(accountKeys)-1)
	}
	obj.RentReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClosePresetParameter2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.PresetParameter)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.RentReceiver)
	return keys
}

func (obj *ClosePresetParameter2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClosePresetParameter2Instruction: %w", err)
	}
	return nil
}

func UnmarshalClosePresetParameter2Instruction(buf []byte) (*ClosePresetParameter2Instruction, error) {
	obj := new(ClosePresetParameter2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CreateClaimProtocolFeeOperatorInstruction struct {

	// Accounts:
	ClaimFeeOperator         solanago.PublicKey `json:"claim_fee_operator"`
	ClaimFeeOperatorWritable bool               `json:"claim_fee_operator_writable"`
	Operator                 solanago.PublicKey `json:"operator"`
	Admin                    solanago.PublicKey `json:"admin"`
	AdminWritable            bool               `json:"admin_writable"`
	AdminSigner              bool               `json:"admin_signer"`
	SystemProgram            solanago.PublicKey `json:"system_program"`
}

func (obj *CreateClaimProtocolFeeOperatorInstruction) GetDiscriminator() []byte {
	return Instruction_CreateClaimProtocolFeeOperator[:]
}

func (obj *CreateClaimProtocolFeeOperatorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *CreateClaimProtocolFeeOperatorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from claim_fee_operator account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "claim_fee_operator", err)
	}
	indices = append(indices, index)
	// Decode from operator account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operator", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CreateClaimProtocolFeeOperatorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set claim_fee_operator account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "claim_fee_operator", len(accountKeys)-1)
	}
	obj.ClaimFeeOperator = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set operator account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operator", len(accountKeys)-1)
	}
	obj.Operator = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CreateClaimProtocolFeeOperatorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.ClaimFeeOperator)
	keys = append(keys, obj.Operator)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.SystemProgram)
	return keys
}

func (obj *CreateClaimProtocolFeeOperatorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CreateClaimProtocolFeeOperatorInstruction: %w", err)
	}
	return nil
}

func UnmarshalCreateClaimProtocolFeeOperatorInstruction(buf []byte) (*CreateClaimProtocolFeeOperatorInstruction, error) {
	obj := new(CreateClaimProtocolFeeOperatorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DecreasePositionLengthInstruction struct {
	LengthToRemove uint16 `json:"length_to_remove"`
	Side           uint8  `json:"side"`

	// Accounts:
	RentReceiver         solanago.PublicKey `json:"rent_receiver"`
	RentReceiverWritable bool               `json:"rent_receiver_writable"`
	Position             solanago.PublicKey `json:"position"`
	PositionWritable     bool               `json:"position_writable"`
	Owner                solanago.PublicKey `json:"owner"`
	OwnerSigner          bool               `json:"owner_signer"`
	SystemProgram        solanago.PublicKey `json:"system_program"`
	EventAuthority       solanago.PublicKey `json:"event_authority"`
	Program              solanago.PublicKey `json:"program"`
}

func (obj *DecreasePositionLengthInstruction) GetDiscriminator() []byte {
	return Instruction_DecreasePositionLength[:]
}

func (obj *DecreasePositionLengthInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LengthToRemove`:
	err = decoder.Decode(&obj.LengthToRemove)
	if err != nil {
		return err
	}
	// Deserialize `Side`:
	err = decoder.Decode(&obj.Side)
	if err != nil {
		return err
	}
	return nil
}

func (obj *DecreasePositionLengthInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from rent_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent_receiver", err)
	}
	indices = append(indices, index)
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *DecreasePositionLengthInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set rent_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent_receiver", len(accountKeys)-1)
	}
	obj.RentReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *DecreasePositionLengthInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.RentReceiver)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *DecreasePositionLengthInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DecreasePositionLengthInstruction: %w", err)
	}
	return nil
}

func UnmarshalDecreasePositionLengthInstruction(buf []byte) (*DecreasePositionLengthInstruction, error) {
	obj := new(DecreasePositionLengthInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ForIdlTypeGenerationDoNotCallInstruction struct {
	Ix DummyIx `json:"_ix"`

	// Accounts:
	DummyZcAccount solanago.PublicKey `json:"dummy_zc_account"`
}

func (obj *ForIdlTypeGenerationDoNotCallInstruction) GetDiscriminator() []byte {
	return Instruction_ForIdlTypeGenerationDoNotCall[:]
}

func (obj *ForIdlTypeGenerationDoNotCallInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Ix`:
	err = decoder.Decode(&obj.Ix)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ForIdlTypeGenerationDoNotCallInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from dummy_zc_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dummy_zc_account", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ForIdlTypeGenerationDoNotCallInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set dummy_zc_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dummy_zc_account", len(accountKeys)-1)
	}
	obj.DummyZcAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ForIdlTypeGenerationDoNotCallInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.DummyZcAccount)
	return keys
}

func (obj *ForIdlTypeGenerationDoNotCallInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ForIdlTypeGenerationDoNotCallInstruction: %w", err)
	}
	return nil
}

func UnmarshalForIdlTypeGenerationDoNotCallInstruction(buf []byte) (*ForIdlTypeGenerationDoNotCallInstruction, error) {
	obj := new(ForIdlTypeGenerationDoNotCallInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type FundRewardInstruction struct {
	RewardIndex           uint64                `json:"reward_index"`
	Amount                uint64                `json:"amount"`
	CarryForward          bool                  `json:"carry_forward"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	LbPair                     solanago.PublicKey `json:"lb_pair"`
	LbPairWritable             bool               `json:"lb_pair_writable"`
	RewardVault                solanago.PublicKey `json:"reward_vault"`
	RewardVaultWritable        bool               `json:"reward_vault_writable"`
	RewardMint                 solanago.PublicKey `json:"reward_mint"`
	FunderTokenAccount         solanago.PublicKey `json:"funder_token_account"`
	FunderTokenAccountWritable bool               `json:"funder_token_account_writable"`
	Funder                     solanago.PublicKey `json:"funder"`
	FunderSigner               bool               `json:"funder_signer"`
	BinArray                   solanago.PublicKey `json:"bin_array"`
	BinArrayWritable           bool               `json:"bin_array_writable"`
	TokenProgram               solanago.PublicKey `json:"token_program"`
	EventAuthority             solanago.PublicKey `json:"event_authority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *FundRewardInstruction) GetDiscriminator() []byte {
	return Instruction_FundReward[:]
}

func (obj *FundRewardInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `RewardIndex`:
	err = decoder.Decode(&obj.RewardIndex)
	if err != nil {
		return err
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `CarryForward`:
	err = decoder.Decode(&obj.CarryForward)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FundRewardInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from reward_vault account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_vault", err)
	}
	indices = append(indices, index)
	// Decode from reward_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_mint", err)
	}
	indices = append(indices, index)
	// Decode from funder_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder_token_account", err)
	}
	indices = append(indices, index)
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from bin_array account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *FundRewardInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 9 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 9, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_vault account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_vault", len(accountKeys)-1)
	}
	obj.RewardVault = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_mint", len(accountKeys)-1)
	}
	obj.RewardMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder_token_account", len(accountKeys)-1)
	}
	obj.FunderTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array", len(accountKeys)-1)
	}
	obj.BinArray = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *FundRewardInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.RewardVault)
	keys = append(keys, obj.RewardMint)
	keys = append(keys, obj.FunderTokenAccount)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.BinArray)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *FundRewardInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling FundRewardInstruction: %w", err)
	}
	return nil
}

func UnmarshalFundRewardInstruction(buf []byte) (*FundRewardInstruction, error) {
	obj := new(FundRewardInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type GoToABinInstruction struct {
	BinId int32 `json:"bin_id"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	FromBinArray                    solanago.PublicKey `json:"from_bin_array"`
	FromBinArrayOptional            bool               `json:"from_bin_array_optional"`
	ToBinArray                      solanago.PublicKey `json:"to_bin_array"`
	ToBinArrayOptional              bool               `json:"to_bin_array_optional"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *GoToABinInstruction) GetDiscriminator() []byte {
	return Instruction_GoToABin[:]
}

func (obj *GoToABinInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `BinId`:
	err = decoder.Decode(&obj.BinId)
	if err != nil {
		return err
	}
	return nil
}

func (obj *GoToABinInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from from_bin_array account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "from_bin_array", err)
	}
	indices = append(indices, index)
	// Decode from to_bin_array account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "to_bin_array", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *GoToABinInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set from_bin_array account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "from_bin_array", len(accountKeys)-1)
	}
	obj.FromBinArray = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set to_bin_array account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "to_bin_array", len(accountKeys)-1)
	}
	obj.ToBinArray = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *GoToABinInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.FromBinArray)
	keys = append(keys, obj.ToBinArray)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *GoToABinInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling GoToABinInstruction: %w", err)
	}
	return nil
}

func UnmarshalGoToABinInstruction(buf []byte) (*GoToABinInstruction, error) {
	obj := new(GoToABinInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type IncreaseOracleLengthInstruction struct {
	LengthToAdd uint64 `json:"length_to_add"`

	// Accounts:
	Oracle         solanago.PublicKey `json:"oracle"`
	OracleWritable bool               `json:"oracle_writable"`
	Funder         solanago.PublicKey `json:"funder"`
	FunderWritable bool               `json:"funder_writable"`
	FunderSigner   bool               `json:"funder_signer"`
	SystemProgram  solanago.PublicKey `json:"system_program"`
	EventAuthority solanago.PublicKey `json:"event_authority"`
	Program        solanago.PublicKey `json:"program"`
}

func (obj *IncreaseOracleLengthInstruction) GetDiscriminator() []byte {
	return Instruction_IncreaseOracleLength[:]
}

func (obj *IncreaseOracleLengthInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LengthToAdd`:
	err = decoder.Decode(&obj.LengthToAdd)
	if err != nil {
		return err
	}
	return nil
}

func (obj *IncreaseOracleLengthInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *IncreaseOracleLengthInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *IncreaseOracleLengthInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *IncreaseOracleLengthInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IncreaseOracleLengthInstruction: %w", err)
	}
	return nil
}

func UnmarshalIncreaseOracleLengthInstruction(buf []byte) (*IncreaseOracleLengthInstruction, error) {
	obj := new(IncreaseOracleLengthInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type IncreasePositionLengthInstruction struct {
	LengthToAdd uint16 `json:"length_to_add"`
	Side        uint8  `json:"side"`

	// Accounts:
	Funder           solanago.PublicKey `json:"funder"`
	FunderWritable   bool               `json:"funder_writable"`
	FunderSigner     bool               `json:"funder_signer"`
	LbPair           solanago.PublicKey `json:"lb_pair"`
	Position         solanago.PublicKey `json:"position"`
	PositionWritable bool               `json:"position_writable"`
	Owner            solanago.PublicKey `json:"owner"`
	OwnerSigner      bool               `json:"owner_signer"`
	SystemProgram    solanago.PublicKey `json:"system_program"`
	EventAuthority   solanago.PublicKey `json:"event_authority"`
	Program          solanago.PublicKey `json:"program"`
}

func (obj *IncreasePositionLengthInstruction) GetDiscriminator() []byte {
	return Instruction_IncreasePositionLength[:]
}

func (obj *IncreasePositionLengthInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LengthToAdd`:
	err = decoder.Decode(&obj.LengthToAdd)
	if err != nil {
		return err
	}
	// Deserialize `Side`:
	err = decoder.Decode(&obj.Side)
	if err != nil {
		return err
	}
	return nil
}

func (obj *IncreasePositionLengthInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *IncreasePositionLengthInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *IncreasePositionLengthInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *IncreasePositionLengthInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IncreasePositionLengthInstruction: %w", err)
	}
	return nil
}

func UnmarshalIncreasePositionLengthInstruction(buf []byte) (*IncreasePositionLengthInstruction, error) {
	obj := new(IncreasePositionLengthInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeBinArrayInstruction struct {
	Index int64 `json:"index"`

	// Accounts:
	LbPair           solanago.PublicKey `json:"lb_pair"`
	BinArray         solanago.PublicKey `json:"bin_array"`
	BinArrayWritable bool               `json:"bin_array_writable"`
	Funder           solanago.PublicKey `json:"funder"`
	FunderWritable   bool               `json:"funder_writable"`
	FunderSigner     bool               `json:"funder_signer"`
	SystemProgram    solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeBinArrayInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeBinArray[:]
}

func (obj *InitializeBinArrayInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Index`:
	err = decoder.Decode(&obj.Index)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeBinArrayInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array", err)
	}
	indices = append(indices, index)
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeBinArrayInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array", len(accountKeys)-1)
	}
	obj.BinArray = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeBinArrayInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArray)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.SystemProgram)
	return keys
}

func (obj *InitializeBinArrayInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeBinArrayInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializeBinArrayInstruction(buf []byte) (*InitializeBinArrayInstruction, error) {
	obj := new(InitializeBinArrayInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeBinArrayBitmapExtensionInstruction struct {

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	Funder                          solanago.PublicKey `json:"funder"`
	FunderWritable                  bool               `json:"funder_writable"`
	FunderSigner                    bool               `json:"funder_signer"`
	SystemProgram                   solanago.PublicKey `json:"system_program"`
	Rent                            solanago.PublicKey `json:"rent"`
}

func (obj *InitializeBinArrayBitmapExtensionInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeBinArrayBitmapExtension[:]
}

func (obj *InitializeBinArrayBitmapExtensionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *InitializeBinArrayBitmapExtensionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from rent account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeBinArrayBitmapExtensionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent", len(accountKeys)-1)
	}
	obj.Rent = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeBinArrayBitmapExtensionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Rent)
	return keys
}

func (obj *InitializeBinArrayBitmapExtensionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeBinArrayBitmapExtensionInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializeBinArrayBitmapExtensionInstruction(buf []byte) (*InitializeBinArrayBitmapExtensionInstruction, error) {
	obj := new(InitializeBinArrayBitmapExtensionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeCustomizablePermissionlessLbPairInstruction struct {
	Params CustomizableParams `json:"params"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	TokenMintX                      solanago.PublicKey `json:"token_mint_x"`
	TokenMintY                      solanago.PublicKey `json:"token_mint_y"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	Funder                          solanago.PublicKey `json:"funder"`
	FunderWritable                  bool               `json:"funder_writable"`
	FunderSigner                    bool               `json:"funder_signer"`
	TokenProgram                    solanago.PublicKey `json:"token_program"`
	SystemProgram                   solanago.PublicKey `json:"system_program"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *InitializeCustomizablePermissionlessLbPairInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeCustomizablePermissionlessLbPair[:]
}

func (obj *InitializeCustomizablePermissionlessLbPairInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeCustomizablePermissionlessLbPairInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_x", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeCustomizablePermissionlessLbPairInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 14 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 14, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_x", len(accountKeys)-1)
	}
	obj.TokenMintX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_y", len(accountKeys)-1)
	}
	obj.TokenMintY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeCustomizablePermissionlessLbPairInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.TokenMintX)
	keys = append(keys, obj.TokenMintY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *InitializeCustomizablePermissionlessLbPairInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeCustomizablePermissionlessLbPairInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializeCustomizablePermissionlessLbPairInstruction(buf []byte) (*InitializeCustomizablePermissionlessLbPairInstruction, error) {
	obj := new(InitializeCustomizablePermissionlessLbPairInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeCustomizablePermissionlessLbPair2Instruction struct {
	Params CustomizableParams `json:"params"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	TokenMintX                      solanago.PublicKey `json:"token_mint_x"`
	TokenMintY                      solanago.PublicKey `json:"token_mint_y"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	Funder                          solanago.PublicKey `json:"funder"`
	FunderWritable                  bool               `json:"funder_writable"`
	FunderSigner                    bool               `json:"funder_signer"`
	TokenBadgeX                     solanago.PublicKey `json:"token_badge_x"`
	TokenBadgeXOptional             bool               `json:"token_badge_x_optional"`
	TokenBadgeY                     solanago.PublicKey `json:"token_badge_y"`
	TokenBadgeYOptional             bool               `json:"token_badge_y_optional"`
	TokenProgramX                   solanago.PublicKey `json:"token_program_x"`
	TokenProgramY                   solanago.PublicKey `json:"token_program_y"`
	SystemProgram                   solanago.PublicKey `json:"system_program"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *InitializeCustomizablePermissionlessLbPair2Instruction) GetDiscriminator() []byte {
	return Instruction_InitializeCustomizablePermissionlessLbPair2[:]
}

func (obj *InitializeCustomizablePermissionlessLbPair2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeCustomizablePermissionlessLbPair2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_x", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from token_badge_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_badge_x", err)
	}
	indices = append(indices, index)
	// Decode from token_badge_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_badge_y", err)
	}
	indices = append(indices, index)
	// Decode from token_program_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program_x", err)
	}
	indices = append(indices, index)
	// Decode from token_program_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program_y", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeCustomizablePermissionlessLbPair2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 17 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 17, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_x", len(accountKeys)-1)
	}
	obj.TokenMintX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_y", len(accountKeys)-1)
	}
	obj.TokenMintY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_badge_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_badge_x", len(accountKeys)-1)
	}
	obj.TokenBadgeX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_badge_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_badge_y", len(accountKeys)-1)
	}
	obj.TokenBadgeY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program_x", len(accountKeys)-1)
	}
	obj.TokenProgramX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program_y", len(accountKeys)-1)
	}
	obj.TokenProgramY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeCustomizablePermissionlessLbPair2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.TokenMintX)
	keys = append(keys, obj.TokenMintY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.TokenBadgeX)
	keys = append(keys, obj.TokenBadgeY)
	keys = append(keys, obj.TokenProgramX)
	keys = append(keys, obj.TokenProgramY)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *InitializeCustomizablePermissionlessLbPair2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeCustomizablePermissionlessLbPair2Instruction: %w", err)
	}
	return nil
}

func UnmarshalInitializeCustomizablePermissionlessLbPair2Instruction(buf []byte) (*InitializeCustomizablePermissionlessLbPair2Instruction, error) {
	obj := new(InitializeCustomizablePermissionlessLbPair2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeLbPairInstruction struct {
	ActiveId int32  `json:"active_id"`
	BinStep  uint16 `json:"bin_step"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	TokenMintX                      solanago.PublicKey `json:"token_mint_x"`
	TokenMintY                      solanago.PublicKey `json:"token_mint_y"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	PresetParameter                 solanago.PublicKey `json:"preset_parameter"`
	Funder                          solanago.PublicKey `json:"funder"`
	FunderWritable                  bool               `json:"funder_writable"`
	FunderSigner                    bool               `json:"funder_signer"`
	TokenProgram                    solanago.PublicKey `json:"token_program"`
	SystemProgram                   solanago.PublicKey `json:"system_program"`
	Rent                            solanago.PublicKey `json:"rent"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *InitializeLbPairInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeLbPair[:]
}

func (obj *InitializeLbPairInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `ActiveId`:
	err = decoder.Decode(&obj.ActiveId)
	if err != nil {
		return err
	}
	// Deserialize `BinStep`:
	err = decoder.Decode(&obj.BinStep)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeLbPairInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_x", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from preset_parameter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "preset_parameter", err)
	}
	indices = append(indices, index)
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from rent account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeLbPairInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 14 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 14, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_x", len(accountKeys)-1)
	}
	obj.TokenMintX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_y", len(accountKeys)-1)
	}
	obj.TokenMintY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set preset_parameter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "preset_parameter", len(accountKeys)-1)
	}
	obj.PresetParameter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent", len(accountKeys)-1)
	}
	obj.Rent = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeLbPairInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.TokenMintX)
	keys = append(keys, obj.TokenMintY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.PresetParameter)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Rent)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *InitializeLbPairInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeLbPairInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializeLbPairInstruction(buf []byte) (*InitializeLbPairInstruction, error) {
	obj := new(InitializeLbPairInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeLbPair2Instruction struct {
	Params InitializeLbPair2Params `json:"params"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	TokenMintX                      solanago.PublicKey `json:"token_mint_x"`
	TokenMintY                      solanago.PublicKey `json:"token_mint_y"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	PresetParameter                 solanago.PublicKey `json:"preset_parameter"`
	Funder                          solanago.PublicKey `json:"funder"`
	FunderWritable                  bool               `json:"funder_writable"`
	FunderSigner                    bool               `json:"funder_signer"`
	TokenBadgeX                     solanago.PublicKey `json:"token_badge_x"`
	TokenBadgeXOptional             bool               `json:"token_badge_x_optional"`
	TokenBadgeY                     solanago.PublicKey `json:"token_badge_y"`
	TokenBadgeYOptional             bool               `json:"token_badge_y_optional"`
	TokenProgramX                   solanago.PublicKey `json:"token_program_x"`
	TokenProgramY                   solanago.PublicKey `json:"token_program_y"`
	SystemProgram                   solanago.PublicKey `json:"system_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *InitializeLbPair2Instruction) GetDiscriminator() []byte {
	return Instruction_InitializeLbPair2[:]
}

func (obj *InitializeLbPair2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeLbPair2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_x", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from preset_parameter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "preset_parameter", err)
	}
	indices = append(indices, index)
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from token_badge_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_badge_x", err)
	}
	indices = append(indices, index)
	// Decode from token_badge_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_badge_y", err)
	}
	indices = append(indices, index)
	// Decode from token_program_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program_x", err)
	}
	indices = append(indices, index)
	// Decode from token_program_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program_y", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeLbPair2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_x", len(accountKeys)-1)
	}
	obj.TokenMintX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_y", len(accountKeys)-1)
	}
	obj.TokenMintY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set preset_parameter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "preset_parameter", len(accountKeys)-1)
	}
	obj.PresetParameter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_badge_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_badge_x", len(accountKeys)-1)
	}
	obj.TokenBadgeX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_badge_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_badge_y", len(accountKeys)-1)
	}
	obj.TokenBadgeY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program_x", len(accountKeys)-1)
	}
	obj.TokenProgramX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program_y", len(accountKeys)-1)
	}
	obj.TokenProgramY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeLbPair2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.TokenMintX)
	keys = append(keys, obj.TokenMintY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.PresetParameter)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.TokenBadgeX)
	keys = append(keys, obj.TokenBadgeY)
	keys = append(keys, obj.TokenProgramX)
	keys = append(keys, obj.TokenProgramY)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *InitializeLbPair2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeLbPair2Instruction: %w", err)
	}
	return nil
}

func UnmarshalInitializeLbPair2Instruction(buf []byte) (*InitializeLbPair2Instruction, error) {
	obj := new(InitializeLbPair2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializePermissionLbPairInstruction struct {
	IxData InitPermissionPairIx `json:"ix_data"`

	// Accounts:
	Base                            solanago.PublicKey `json:"base"`
	BaseSigner                      bool               `json:"base_signer"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	TokenMintX                      solanago.PublicKey `json:"token_mint_x"`
	TokenMintY                      solanago.PublicKey `json:"token_mint_y"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	Admin                           solanago.PublicKey `json:"admin"`
	AdminWritable                   bool               `json:"admin_writable"`
	AdminSigner                     bool               `json:"admin_signer"`
	TokenBadgeX                     solanago.PublicKey `json:"token_badge_x"`
	TokenBadgeXOptional             bool               `json:"token_badge_x_optional"`
	TokenBadgeY                     solanago.PublicKey `json:"token_badge_y"`
	TokenBadgeYOptional             bool               `json:"token_badge_y_optional"`
	TokenProgramX                   solanago.PublicKey `json:"token_program_x"`
	TokenProgramY                   solanago.PublicKey `json:"token_program_y"`
	SystemProgram                   solanago.PublicKey `json:"system_program"`
	Rent                            solanago.PublicKey `json:"rent"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *InitializePermissionLbPairInstruction) GetDiscriminator() []byte {
	return Instruction_InitializePermissionLbPair[:]
}

func (obj *InitializePermissionLbPairInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `IxData`:
	err = decoder.Decode(&obj.IxData)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializePermissionLbPairInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from base account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "base", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_x", err)
	}
	indices = append(indices, index)
	// Decode from token_mint_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from token_badge_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_badge_x", err)
	}
	indices = append(indices, index)
	// Decode from token_badge_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_badge_y", err)
	}
	indices = append(indices, index)
	// Decode from token_program_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program_x", err)
	}
	indices = append(indices, index)
	// Decode from token_program_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program_y", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from rent account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializePermissionLbPairInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 17 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 17, len(indices))
	}
	indexOffset := 0
	// Set base account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "base", len(accountKeys)-1)
	}
	obj.Base = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_x", len(accountKeys)-1)
	}
	obj.TokenMintX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_mint_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint_y", len(accountKeys)-1)
	}
	obj.TokenMintY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_badge_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_badge_x", len(accountKeys)-1)
	}
	obj.TokenBadgeX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_badge_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_badge_y", len(accountKeys)-1)
	}
	obj.TokenBadgeY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program_x", len(accountKeys)-1)
	}
	obj.TokenProgramX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program_y", len(accountKeys)-1)
	}
	obj.TokenProgramY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent", len(accountKeys)-1)
	}
	obj.Rent = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializePermissionLbPairInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Base)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.TokenMintX)
	keys = append(keys, obj.TokenMintY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.TokenBadgeX)
	keys = append(keys, obj.TokenBadgeY)
	keys = append(keys, obj.TokenProgramX)
	keys = append(keys, obj.TokenProgramY)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Rent)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *InitializePermissionLbPairInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializePermissionLbPairInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializePermissionLbPairInstruction(buf []byte) (*InitializePermissionLbPairInstruction, error) {
	obj := new(InitializePermissionLbPairInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializePositionInstruction struct {
	LowerBinId int32 `json:"lower_bin_id"`
	Width      int32 `json:"width"`

	// Accounts:
	Payer            solanago.PublicKey `json:"payer"`
	PayerWritable    bool               `json:"payer_writable"`
	PayerSigner      bool               `json:"payer_signer"`
	Position         solanago.PublicKey `json:"position"`
	PositionWritable bool               `json:"position_writable"`
	PositionSigner   bool               `json:"position_signer"`
	LbPair           solanago.PublicKey `json:"lb_pair"`
	Owner            solanago.PublicKey `json:"owner"`
	OwnerSigner      bool               `json:"owner_signer"`
	SystemProgram    solanago.PublicKey `json:"system_program"`
	Rent             solanago.PublicKey `json:"rent"`
	EventAuthority   solanago.PublicKey `json:"event_authority"`
	Program          solanago.PublicKey `json:"program"`
}

func (obj *InitializePositionInstruction) GetDiscriminator() []byte {
	return Instruction_InitializePosition[:]
}

func (obj *InitializePositionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LowerBinId`:
	err = decoder.Decode(&obj.LowerBinId)
	if err != nil {
		return err
	}
	// Deserialize `Width`:
	err = decoder.Decode(&obj.Width)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializePositionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from rent account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializePositionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 8 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 8, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent", len(accountKeys)-1)
	}
	obj.Rent = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializePositionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Rent)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *InitializePositionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializePositionInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializePositionInstruction(buf []byte) (*InitializePositionInstruction, error) {
	obj := new(InitializePositionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializePositionByOperatorInstruction struct {
	LowerBinId       int32              `json:"lower_bin_id"`
	Width            int32              `json:"width"`
	FeeOwner         solanago.PublicKey `json:"fee_owner"`
	LockReleasePoint uint64             `json:"lock_release_point"`

	// Accounts:
	Payer            solanago.PublicKey `json:"payer"`
	PayerWritable    bool               `json:"payer_writable"`
	PayerSigner      bool               `json:"payer_signer"`
	Base             solanago.PublicKey `json:"base"`
	BaseSigner       bool               `json:"base_signer"`
	Position         solanago.PublicKey `json:"position"`
	PositionWritable bool               `json:"position_writable"`
	LbPair           solanago.PublicKey `json:"lb_pair"`
	Owner            solanago.PublicKey `json:"owner"`
	Operator         solanago.PublicKey `json:"operator"`
	OperatorSigner   bool               `json:"operator_signer"`
	OperatorTokenX   solanago.PublicKey `json:"operator_token_x"`
	OwnerTokenX      solanago.PublicKey `json:"owner_token_x"`
	SystemProgram    solanago.PublicKey `json:"system_program"`
	EventAuthority   solanago.PublicKey `json:"event_authority"`
	Program          solanago.PublicKey `json:"program"`
}

func (obj *InitializePositionByOperatorInstruction) GetDiscriminator() []byte {
	return Instruction_InitializePositionByOperator[:]
}

func (obj *InitializePositionByOperatorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LowerBinId`:
	err = decoder.Decode(&obj.LowerBinId)
	if err != nil {
		return err
	}
	// Deserialize `Width`:
	err = decoder.Decode(&obj.Width)
	if err != nil {
		return err
	}
	// Deserialize `FeeOwner`:
	err = decoder.Decode(&obj.FeeOwner)
	if err != nil {
		return err
	}
	// Deserialize `LockReleasePoint`:
	err = decoder.Decode(&obj.LockReleasePoint)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializePositionByOperatorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from base account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "base", err)
	}
	indices = append(indices, index)
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from operator account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operator", err)
	}
	indices = append(indices, index)
	// Decode from operator_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operator_token_x", err)
	}
	indices = append(indices, index)
	// Decode from owner_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner_token_x", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializePositionByOperatorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 11 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 11, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set base account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "base", len(accountKeys)-1)
	}
	obj.Base = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set operator account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operator", len(accountKeys)-1)
	}
	obj.Operator = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set operator_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operator_token_x", len(accountKeys)-1)
	}
	obj.OperatorTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner_token_x", len(accountKeys)-1)
	}
	obj.OwnerTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializePositionByOperatorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.Base)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.Operator)
	keys = append(keys, obj.OperatorTokenX)
	keys = append(keys, obj.OwnerTokenX)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *InitializePositionByOperatorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializePositionByOperatorInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializePositionByOperatorInstruction(buf []byte) (*InitializePositionByOperatorInstruction, error) {
	obj := new(InitializePositionByOperatorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializePositionPdaInstruction struct {
	LowerBinId int32 `json:"lower_bin_id"`
	Width      int32 `json:"width"`

	// Accounts:
	Payer            solanago.PublicKey `json:"payer"`
	PayerWritable    bool               `json:"payer_writable"`
	PayerSigner      bool               `json:"payer_signer"`
	Base             solanago.PublicKey `json:"base"`
	BaseSigner       bool               `json:"base_signer"`
	Position         solanago.PublicKey `json:"position"`
	PositionWritable bool               `json:"position_writable"`
	LbPair           solanago.PublicKey `json:"lb_pair"`
	Owner            solanago.PublicKey `json:"owner"`
	OwnerSigner      bool               `json:"owner_signer"`
	SystemProgram    solanago.PublicKey `json:"system_program"`
	Rent             solanago.PublicKey `json:"rent"`
	EventAuthority   solanago.PublicKey `json:"event_authority"`
	Program          solanago.PublicKey `json:"program"`
}

func (obj *InitializePositionPdaInstruction) GetDiscriminator() []byte {
	return Instruction_InitializePositionPda[:]
}

func (obj *InitializePositionPdaInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `LowerBinId`:
	err = decoder.Decode(&obj.LowerBinId)
	if err != nil {
		return err
	}
	// Deserialize `Width`:
	err = decoder.Decode(&obj.Width)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializePositionPdaInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from base account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "base", err)
	}
	indices = append(indices, index)
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from rent account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializePositionPdaInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 9 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 9, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set base account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "base", len(accountKeys)-1)
	}
	obj.Base = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent", len(accountKeys)-1)
	}
	obj.Rent = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializePositionPdaInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.Base)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Rent)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *InitializePositionPdaInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializePositionPdaInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializePositionPdaInstruction(buf []byte) (*InitializePositionPdaInstruction, error) {
	obj := new(InitializePositionPdaInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializePresetParameterInstruction struct {
	Ix InitPresetParametersIx `json:"ix"`

	// Accounts:
	PresetParameter         solanago.PublicKey `json:"preset_parameter"`
	PresetParameterWritable bool               `json:"preset_parameter_writable"`
	Admin                   solanago.PublicKey `json:"admin"`
	AdminWritable           bool               `json:"admin_writable"`
	AdminSigner             bool               `json:"admin_signer"`
	SystemProgram           solanago.PublicKey `json:"system_program"`
	Rent                    solanago.PublicKey `json:"rent"`
}

func (obj *InitializePresetParameterInstruction) GetDiscriminator() []byte {
	return Instruction_InitializePresetParameter[:]
}

func (obj *InitializePresetParameterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Ix`:
	err = decoder.Decode(&obj.Ix)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializePresetParameterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from preset_parameter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "preset_parameter", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from rent account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializePresetParameterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set preset_parameter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "preset_parameter", len(accountKeys)-1)
	}
	obj.PresetParameter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent", len(accountKeys)-1)
	}
	obj.Rent = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializePresetParameterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.PresetParameter)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Rent)
	return keys
}

func (obj *InitializePresetParameterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializePresetParameterInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializePresetParameterInstruction(buf []byte) (*InitializePresetParameterInstruction, error) {
	obj := new(InitializePresetParameterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializePresetParameter2Instruction struct {
	Ix InitPresetParameters2Ix `json:"ix"`

	// Accounts:
	PresetParameter         solanago.PublicKey `json:"preset_parameter"`
	PresetParameterWritable bool               `json:"preset_parameter_writable"`
	Admin                   solanago.PublicKey `json:"admin"`
	AdminWritable           bool               `json:"admin_writable"`
	AdminSigner             bool               `json:"admin_signer"`
	SystemProgram           solanago.PublicKey `json:"system_program"`
}

func (obj *InitializePresetParameter2Instruction) GetDiscriminator() []byte {
	return Instruction_InitializePresetParameter2[:]
}

func (obj *InitializePresetParameter2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Ix`:
	err = decoder.Decode(&obj.Ix)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializePresetParameter2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from preset_parameter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "preset_parameter", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializePresetParameter2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set preset_parameter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "preset_parameter", len(accountKeys)-1)
	}
	obj.PresetParameter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializePresetParameter2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.PresetParameter)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.SystemProgram)
	return keys
}

func (obj *InitializePresetParameter2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializePresetParameter2Instruction: %w", err)
	}
	return nil
}

func UnmarshalInitializePresetParameter2Instruction(buf []byte) (*InitializePresetParameter2Instruction, error) {
	obj := new(InitializePresetParameter2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeRewardInstruction struct {
	RewardIndex    uint64             `json:"reward_index"`
	RewardDuration uint64             `json:"reward_duration"`
	Funder         solanago.PublicKey `json:"funder"`

	// Accounts:
	LbPair              solanago.PublicKey `json:"lb_pair"`
	LbPairWritable      bool               `json:"lb_pair_writable"`
	RewardVault         solanago.PublicKey `json:"reward_vault"`
	RewardVaultWritable bool               `json:"reward_vault_writable"`
	RewardMint          solanago.PublicKey `json:"reward_mint"`
	TokenBadge          solanago.PublicKey `json:"token_badge"`
	TokenBadgeOptional  bool               `json:"token_badge_optional"`
	Admin               solanago.PublicKey `json:"admin"`
	AdminWritable       bool               `json:"admin_writable"`
	AdminSigner         bool               `json:"admin_signer"`
	TokenProgram        solanago.PublicKey `json:"token_program"`
	SystemProgram       solanago.PublicKey `json:"system_program"`
	Rent                solanago.PublicKey `json:"rent"`
	EventAuthority      solanago.PublicKey `json:"event_authority"`
	Program             solanago.PublicKey `json:"program"`
}

func (obj *InitializeRewardInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeReward[:]
}

func (obj *InitializeRewardInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `RewardIndex`:
	err = decoder.Decode(&obj.RewardIndex)
	if err != nil {
		return err
	}
	// Deserialize `RewardDuration`:
	err = decoder.Decode(&obj.RewardDuration)
	if err != nil {
		return err
	}
	// Deserialize `Funder`:
	err = decoder.Decode(&obj.Funder)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeRewardInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from reward_vault account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_vault", err)
	}
	indices = append(indices, index)
	// Decode from reward_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_badge account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_badge", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from rent account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeRewardInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_vault account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_vault", len(accountKeys)-1)
	}
	obj.RewardVault = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_mint", len(accountKeys)-1)
	}
	obj.RewardMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_badge account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_badge", len(accountKeys)-1)
	}
	obj.TokenBadge = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent", len(accountKeys)-1)
	}
	obj.Rent = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeRewardInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.RewardVault)
	keys = append(keys, obj.RewardMint)
	keys = append(keys, obj.TokenBadge)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Rent)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *InitializeRewardInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeRewardInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializeRewardInstruction(buf []byte) (*InitializeRewardInstruction, error) {
	obj := new(InitializeRewardInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeTokenBadgeInstruction struct {

	// Accounts:
	TokenMint          solanago.PublicKey `json:"token_mint"`
	TokenBadge         solanago.PublicKey `json:"token_badge"`
	TokenBadgeWritable bool               `json:"token_badge_writable"`
	Admin              solanago.PublicKey `json:"admin"`
	AdminWritable      bool               `json:"admin_writable"`
	AdminSigner        bool               `json:"admin_signer"`
	SystemProgram      solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeTokenBadgeInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeTokenBadge[:]
}

func (obj *InitializeTokenBadgeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *InitializeTokenBadgeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_badge account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_badge", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeTokenBadgeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_mint", len(accountKeys)-1)
	}
	obj.TokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_badge account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_badge", len(accountKeys)-1)
	}
	obj.TokenBadge = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeTokenBadgeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.TokenMint)
	keys = append(keys, obj.TokenBadge)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.SystemProgram)
	return keys
}

func (obj *InitializeTokenBadgeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeTokenBadgeInstruction: %w", err)
	}
	return nil
}

func UnmarshalInitializeTokenBadgeInstruction(buf []byte) (*InitializeTokenBadgeInstruction, error) {
	obj := new(InitializeTokenBadgeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type MigrateBinArrayInstruction struct {

	// Accounts:
	LbPair solanago.PublicKey `json:"lb_pair"`
}

func (obj *MigrateBinArrayInstruction) GetDiscriminator() []byte {
	return Instruction_MigrateBinArray[:]
}

func (obj *MigrateBinArrayInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *MigrateBinArrayInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *MigrateBinArrayInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *MigrateBinArrayInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	return keys
}

func (obj *MigrateBinArrayInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MigrateBinArrayInstruction: %w", err)
	}
	return nil
}

func UnmarshalMigrateBinArrayInstruction(buf []byte) (*MigrateBinArrayInstruction, error) {
	obj := new(MigrateBinArrayInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type MigratePositionInstruction struct {

	// Accounts:
	PositionV2            solanago.PublicKey `json:"position_v2"`
	PositionV2Writable    bool               `json:"position_v2_writable"`
	PositionV2Signer      bool               `json:"position_v2_signer"`
	PositionV1            solanago.PublicKey `json:"position_v1"`
	PositionV1Writable    bool               `json:"position_v1_writable"`
	LbPair                solanago.PublicKey `json:"lb_pair"`
	BinArrayLower         solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable bool               `json:"bin_array_lower_writable"`
	BinArrayUpper         solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable bool               `json:"bin_array_upper_writable"`
	Owner                 solanago.PublicKey `json:"owner"`
	OwnerWritable         bool               `json:"owner_writable"`
	OwnerSigner           bool               `json:"owner_signer"`
	SystemProgram         solanago.PublicKey `json:"system_program"`
	RentReceiver          solanago.PublicKey `json:"rent_receiver"`
	RentReceiverWritable  bool               `json:"rent_receiver_writable"`
	EventAuthority        solanago.PublicKey `json:"event_authority"`
	Program               solanago.PublicKey `json:"program"`
}

func (obj *MigratePositionInstruction) GetDiscriminator() []byte {
	return Instruction_MigratePosition[:]
}

func (obj *MigratePositionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *MigratePositionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position_v2 account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position_v2", err)
	}
	indices = append(indices, index)
	// Decode from position_v1 account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position_v1", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from rent_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent_receiver", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *MigratePositionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set position_v2 account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position_v2", len(accountKeys)-1)
	}
	obj.PositionV2 = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set position_v1 account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position_v1", len(accountKeys)-1)
	}
	obj.PositionV1 = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent_receiver", len(accountKeys)-1)
	}
	obj.RentReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *MigratePositionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.PositionV2)
	keys = append(keys, obj.PositionV1)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.RentReceiver)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *MigratePositionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MigratePositionInstruction: %w", err)
	}
	return nil
}

func UnmarshalMigratePositionInstruction(buf []byte) (*MigratePositionInstruction, error) {
	obj := new(MigratePositionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RebalanceLiquidityInstruction struct {
	Params                RebalanceLiquidityParams `json:"params"`
	RemainingAccountsInfo RemainingAccountsInfo    `json:"remaining_accounts_info"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Owner                           solanago.PublicKey `json:"owner"`
	OwnerSigner                     bool               `json:"owner_signer"`
	RentPayer                       solanago.PublicKey `json:"rent_payer"`
	RentPayerWritable               bool               `json:"rent_payer_writable"`
	RentPayerSigner                 bool               `json:"rent_payer_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	MemoProgram                     solanago.PublicKey `json:"memo_program"`
	SystemProgram                   solanago.PublicKey `json:"system_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *RebalanceLiquidityInstruction) GetDiscriminator() []byte {
	return Instruction_RebalanceLiquidity[:]
}

func (obj *RebalanceLiquidityInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RebalanceLiquidityInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from rent_payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rent_payer", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RebalanceLiquidityInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 17 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 17, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rent_payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rent_payer", len(accountKeys)-1)
	}
	obj.RentPayer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RebalanceLiquidityInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.RentPayer)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.MemoProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *RebalanceLiquidityInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RebalanceLiquidityInstruction: %w", err)
	}
	return nil
}

func UnmarshalRebalanceLiquidityInstruction(buf []byte) (*RebalanceLiquidityInstruction, error) {
	obj := new(RebalanceLiquidityInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveAllLiquidityInstruction struct {

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	BinArrayLower                   solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable           bool               `json:"bin_array_lower_writable"`
	BinArrayUpper                   solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable           bool               `json:"bin_array_upper_writable"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *RemoveAllLiquidityInstruction) GetDiscriminator() []byte {
	return Instruction_RemoveAllLiquidity[:]
}

func (obj *RemoveAllLiquidityInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *RemoveAllLiquidityInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveAllLiquidityInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveAllLiquidityInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *RemoveAllLiquidityInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveAllLiquidityInstruction: %w", err)
	}
	return nil
}

func UnmarshalRemoveAllLiquidityInstruction(buf []byte) (*RemoveAllLiquidityInstruction, error) {
	obj := new(RemoveAllLiquidityInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveLiquidityInstruction struct {
	BinLiquidityRemoval []BinLiquidityReduction `json:"bin_liquidity_removal"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	BinArrayLower                   solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable           bool               `json:"bin_array_lower_writable"`
	BinArrayUpper                   solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable           bool               `json:"bin_array_upper_writable"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *RemoveLiquidityInstruction) GetDiscriminator() []byte {
	return Instruction_RemoveLiquidity[:]
}

func (obj *RemoveLiquidityInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `BinLiquidityRemoval`:
	err = decoder.Decode(&obj.BinLiquidityRemoval)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveLiquidityInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveLiquidityInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveLiquidityInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *RemoveLiquidityInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveLiquidityInstruction: %w", err)
	}
	return nil
}

func UnmarshalRemoveLiquidityInstruction(buf []byte) (*RemoveLiquidityInstruction, error) {
	obj := new(RemoveLiquidityInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveLiquidity2Instruction struct {
	BinLiquidityRemoval   []BinLiquidityReduction `json:"bin_liquidity_removal"`
	RemainingAccountsInfo RemainingAccountsInfo   `json:"remaining_accounts_info"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	MemoProgram                     solanago.PublicKey `json:"memo_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *RemoveLiquidity2Instruction) GetDiscriminator() []byte {
	return Instruction_RemoveLiquidity2[:]
}

func (obj *RemoveLiquidity2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `BinLiquidityRemoval`:
	err = decoder.Decode(&obj.BinLiquidityRemoval)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveLiquidity2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveLiquidity2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 15 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 15, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveLiquidity2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.MemoProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *RemoveLiquidity2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveLiquidity2Instruction: %w", err)
	}
	return nil
}

func UnmarshalRemoveLiquidity2Instruction(buf []byte) (*RemoveLiquidity2Instruction, error) {
	obj := new(RemoveLiquidity2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveLiquidityByRangeInstruction struct {
	FromBinId   int32  `json:"from_bin_id"`
	ToBinId     int32  `json:"to_bin_id"`
	BpsToRemove uint16 `json:"bps_to_remove"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	BinArrayLower                   solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable           bool               `json:"bin_array_lower_writable"`
	BinArrayUpper                   solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable           bool               `json:"bin_array_upper_writable"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *RemoveLiquidityByRangeInstruction) GetDiscriminator() []byte {
	return Instruction_RemoveLiquidityByRange[:]
}

func (obj *RemoveLiquidityByRangeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `FromBinId`:
	err = decoder.Decode(&obj.FromBinId)
	if err != nil {
		return err
	}
	// Deserialize `ToBinId`:
	err = decoder.Decode(&obj.ToBinId)
	if err != nil {
		return err
	}
	// Deserialize `BpsToRemove`:
	err = decoder.Decode(&obj.BpsToRemove)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveLiquidityByRangeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveLiquidityByRangeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveLiquidityByRangeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *RemoveLiquidityByRangeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveLiquidityByRangeInstruction: %w", err)
	}
	return nil
}

func UnmarshalRemoveLiquidityByRangeInstruction(buf []byte) (*RemoveLiquidityByRangeInstruction, error) {
	obj := new(RemoveLiquidityByRangeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveLiquidityByRange2Instruction struct {
	FromBinId             int32                 `json:"from_bin_id"`
	ToBinId               int32                 `json:"to_bin_id"`
	BpsToRemove           uint16                `json:"bps_to_remove"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	Position                        solanago.PublicKey `json:"position"`
	PositionWritable                bool               `json:"position_writable"`
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionWritable bool               `json:"bin_array_bitmap_extension_writable"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	UserTokenX                      solanago.PublicKey `json:"user_token_x"`
	UserTokenXWritable              bool               `json:"user_token_x_writable"`
	UserTokenY                      solanago.PublicKey `json:"user_token_y"`
	UserTokenYWritable              bool               `json:"user_token_y_writable"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Sender                          solanago.PublicKey `json:"sender"`
	SenderSigner                    bool               `json:"sender_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	MemoProgram                     solanago.PublicKey `json:"memo_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *RemoveLiquidityByRange2Instruction) GetDiscriminator() []byte {
	return Instruction_RemoveLiquidityByRange2[:]
}

func (obj *RemoveLiquidityByRange2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `FromBinId`:
	err = decoder.Decode(&obj.FromBinId)
	if err != nil {
		return err
	}
	// Deserialize `ToBinId`:
	err = decoder.Decode(&obj.ToBinId)
	if err != nil {
		return err
	}
	// Deserialize `BpsToRemove`:
	err = decoder.Decode(&obj.BpsToRemove)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveLiquidityByRange2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from user_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_x", err)
	}
	indices = append(indices, index)
	// Decode from user_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_y", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sender", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveLiquidityByRange2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 15 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 15, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_x", len(accountKeys)-1)
	}
	obj.UserTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_y", len(accountKeys)-1)
	}
	obj.UserTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sender", len(accountKeys)-1)
	}
	obj.Sender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveLiquidityByRange2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.UserTokenX)
	keys = append(keys, obj.UserTokenY)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Sender)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.MemoProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *RemoveLiquidityByRange2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveLiquidityByRange2Instruction: %w", err)
	}
	return nil
}

func UnmarshalRemoveLiquidityByRange2Instruction(buf []byte) (*RemoveLiquidityByRange2Instruction, error) {
	obj := new(RemoveLiquidityByRange2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetActivationPointInstruction struct {
	ActivationPoint uint64 `json:"activation_point"`

	// Accounts:
	LbPair         solanago.PublicKey `json:"lb_pair"`
	LbPairWritable bool               `json:"lb_pair_writable"`
	Admin          solanago.PublicKey `json:"admin"`
	AdminWritable  bool               `json:"admin_writable"`
	AdminSigner    bool               `json:"admin_signer"`
}

func (obj *SetActivationPointInstruction) GetDiscriminator() []byte {
	return Instruction_SetActivationPoint[:]
}

func (obj *SetActivationPointInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `ActivationPoint`:
	err = decoder.Decode(&obj.ActivationPoint)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetActivationPointInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetActivationPointInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetActivationPointInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Admin)
	return keys
}

func (obj *SetActivationPointInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetActivationPointInstruction: %w", err)
	}
	return nil
}

func UnmarshalSetActivationPointInstruction(buf []byte) (*SetActivationPointInstruction, error) {
	obj := new(SetActivationPointInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetPairStatusInstruction struct {
	Status uint8 `json:"status"`

	// Accounts:
	LbPair         solanago.PublicKey `json:"lb_pair"`
	LbPairWritable bool               `json:"lb_pair_writable"`
	Admin          solanago.PublicKey `json:"admin"`
	AdminSigner    bool               `json:"admin_signer"`
}

func (obj *SetPairStatusInstruction) GetDiscriminator() []byte {
	return Instruction_SetPairStatus[:]
}

func (obj *SetPairStatusInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Status`:
	err = decoder.Decode(&obj.Status)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetPairStatusInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetPairStatusInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetPairStatusInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Admin)
	return keys
}

func (obj *SetPairStatusInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetPairStatusInstruction: %w", err)
	}
	return nil
}

func UnmarshalSetPairStatusInstruction(buf []byte) (*SetPairStatusInstruction, error) {
	obj := new(SetPairStatusInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetPairStatusPermissionlessInstruction struct {
	Status uint8 `json:"status"`

	// Accounts:
	LbPair         solanago.PublicKey `json:"lb_pair"`
	LbPairWritable bool               `json:"lb_pair_writable"`
	Creator        solanago.PublicKey `json:"creator"`
	CreatorSigner  bool               `json:"creator_signer"`
}

func (obj *SetPairStatusPermissionlessInstruction) GetDiscriminator() []byte {
	return Instruction_SetPairStatusPermissionless[:]
}

func (obj *SetPairStatusPermissionlessInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Status`:
	err = decoder.Decode(&obj.Status)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetPairStatusPermissionlessInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from creator account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "creator", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetPairStatusPermissionlessInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set creator account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "creator", len(accountKeys)-1)
	}
	obj.Creator = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetPairStatusPermissionlessInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Creator)
	return keys
}

func (obj *SetPairStatusPermissionlessInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetPairStatusPermissionlessInstruction: %w", err)
	}
	return nil
}

func UnmarshalSetPairStatusPermissionlessInstruction(buf []byte) (*SetPairStatusPermissionlessInstruction, error) {
	obj := new(SetPairStatusPermissionlessInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetPreActivationDurationInstruction struct {
	PreActivationDuration uint64 `json:"pre_activation_duration"`

	// Accounts:
	LbPair         solanago.PublicKey `json:"lb_pair"`
	LbPairWritable bool               `json:"lb_pair_writable"`
	Creator        solanago.PublicKey `json:"creator"`
	CreatorSigner  bool               `json:"creator_signer"`
}

func (obj *SetPreActivationDurationInstruction) GetDiscriminator() []byte {
	return Instruction_SetPreActivationDuration[:]
}

func (obj *SetPreActivationDurationInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `PreActivationDuration`:
	err = decoder.Decode(&obj.PreActivationDuration)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetPreActivationDurationInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from creator account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "creator", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetPreActivationDurationInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set creator account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "creator", len(accountKeys)-1)
	}
	obj.Creator = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetPreActivationDurationInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Creator)
	return keys
}

func (obj *SetPreActivationDurationInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetPreActivationDurationInstruction: %w", err)
	}
	return nil
}

func UnmarshalSetPreActivationDurationInstruction(buf []byte) (*SetPreActivationDurationInstruction, error) {
	obj := new(SetPreActivationDurationInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetPreActivationSwapAddressInstruction struct {
	PreActivationSwapAddress solanago.PublicKey `json:"pre_activation_swap_address"`

	// Accounts:
	LbPair         solanago.PublicKey `json:"lb_pair"`
	LbPairWritable bool               `json:"lb_pair_writable"`
	Creator        solanago.PublicKey `json:"creator"`
	CreatorSigner  bool               `json:"creator_signer"`
}

func (obj *SetPreActivationSwapAddressInstruction) GetDiscriminator() []byte {
	return Instruction_SetPreActivationSwapAddress[:]
}

func (obj *SetPreActivationSwapAddressInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `PreActivationSwapAddress`:
	err = decoder.Decode(&obj.PreActivationSwapAddress)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetPreActivationSwapAddressInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from creator account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "creator", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetPreActivationSwapAddressInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set creator account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "creator", len(accountKeys)-1)
	}
	obj.Creator = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetPreActivationSwapAddressInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Creator)
	return keys
}

func (obj *SetPreActivationSwapAddressInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetPreActivationSwapAddressInstruction: %w", err)
	}
	return nil
}

func UnmarshalSetPreActivationSwapAddressInstruction(buf []byte) (*SetPreActivationSwapAddressInstruction, error) {
	obj := new(SetPreActivationSwapAddressInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SwapInstruction struct {
	AmountIn     uint64 `json:"amount_in"`
	MinAmountOut uint64 `json:"min_amount_out"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	UserTokenIn                     solanago.PublicKey `json:"user_token_in"`
	UserTokenInWritable             bool               `json:"user_token_in_writable"`
	UserTokenOut                    solanago.PublicKey `json:"user_token_out"`
	UserTokenOutWritable            bool               `json:"user_token_out_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	HostFeeIn                       solanago.PublicKey `json:"host_fee_in"`
	HostFeeInWritable               bool               `json:"host_fee_in_writable"`
	HostFeeInOptional               bool               `json:"host_fee_in_optional"`
	User                            solanago.PublicKey `json:"user"`
	UserSigner                      bool               `json:"user_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *SwapInstruction) GetDiscriminator() []byte {
	return Instruction_Swap[:]
}

func (obj *SwapInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `AmountIn`:
	err = decoder.Decode(&obj.AmountIn)
	if err != nil {
		return err
	}
	// Deserialize `MinAmountOut`:
	err = decoder.Decode(&obj.MinAmountOut)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SwapInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from user_token_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_in", err)
	}
	indices = append(indices, index)
	// Decode from user_token_out account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_out", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from host_fee_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "host_fee_in", err)
	}
	indices = append(indices, index)
	// Decode from user account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SwapInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 15 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 15, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_in", len(accountKeys)-1)
	}
	obj.UserTokenIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_out account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_out", len(accountKeys)-1)
	}
	obj.UserTokenOut = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set host_fee_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "host_fee_in", len(accountKeys)-1)
	}
	obj.HostFeeIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user", len(accountKeys)-1)
	}
	obj.User = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SwapInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.UserTokenIn)
	keys = append(keys, obj.UserTokenOut)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.HostFeeIn)
	keys = append(keys, obj.User)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *SwapInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SwapInstruction: %w", err)
	}
	return nil
}

func UnmarshalSwapInstruction(buf []byte) (*SwapInstruction, error) {
	obj := new(SwapInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Swap2Instruction struct {
	AmountIn              uint64                `json:"amount_in"`
	MinAmountOut          uint64                `json:"min_amount_out"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	UserTokenIn                     solanago.PublicKey `json:"user_token_in"`
	UserTokenInWritable             bool               `json:"user_token_in_writable"`
	UserTokenOut                    solanago.PublicKey `json:"user_token_out"`
	UserTokenOutWritable            bool               `json:"user_token_out_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	HostFeeIn                       solanago.PublicKey `json:"host_fee_in"`
	HostFeeInWritable               bool               `json:"host_fee_in_writable"`
	HostFeeInOptional               bool               `json:"host_fee_in_optional"`
	User                            solanago.PublicKey `json:"user"`
	UserSigner                      bool               `json:"user_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	MemoProgram                     solanago.PublicKey `json:"memo_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *Swap2Instruction) GetDiscriminator() []byte {
	return Instruction_Swap2[:]
}

func (obj *Swap2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `AmountIn`:
	err = decoder.Decode(&obj.AmountIn)
	if err != nil {
		return err
	}
	// Deserialize `MinAmountOut`:
	err = decoder.Decode(&obj.MinAmountOut)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Swap2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from user_token_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_in", err)
	}
	indices = append(indices, index)
	// Decode from user_token_out account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_out", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from host_fee_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "host_fee_in", err)
	}
	indices = append(indices, index)
	// Decode from user account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *Swap2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_in", len(accountKeys)-1)
	}
	obj.UserTokenIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_out account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_out", len(accountKeys)-1)
	}
	obj.UserTokenOut = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set host_fee_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "host_fee_in", len(accountKeys)-1)
	}
	obj.HostFeeIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user", len(accountKeys)-1)
	}
	obj.User = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *Swap2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.UserTokenIn)
	keys = append(keys, obj.UserTokenOut)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.HostFeeIn)
	keys = append(keys, obj.User)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.MemoProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *Swap2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Swap2Instruction: %w", err)
	}
	return nil
}

func UnmarshalSwap2Instruction(buf []byte) (*Swap2Instruction, error) {
	obj := new(Swap2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SwapExactOutInstruction struct {
	MaxInAmount uint64 `json:"max_in_amount"`
	OutAmount   uint64 `json:"out_amount"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	UserTokenIn                     solanago.PublicKey `json:"user_token_in"`
	UserTokenInWritable             bool               `json:"user_token_in_writable"`
	UserTokenOut                    solanago.PublicKey `json:"user_token_out"`
	UserTokenOutWritable            bool               `json:"user_token_out_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	HostFeeIn                       solanago.PublicKey `json:"host_fee_in"`
	HostFeeInWritable               bool               `json:"host_fee_in_writable"`
	HostFeeInOptional               bool               `json:"host_fee_in_optional"`
	User                            solanago.PublicKey `json:"user"`
	UserSigner                      bool               `json:"user_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *SwapExactOutInstruction) GetDiscriminator() []byte {
	return Instruction_SwapExactOut[:]
}

func (obj *SwapExactOutInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `MaxInAmount`:
	err = decoder.Decode(&obj.MaxInAmount)
	if err != nil {
		return err
	}
	// Deserialize `OutAmount`:
	err = decoder.Decode(&obj.OutAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SwapExactOutInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from user_token_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_in", err)
	}
	indices = append(indices, index)
	// Decode from user_token_out account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_out", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from host_fee_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "host_fee_in", err)
	}
	indices = append(indices, index)
	// Decode from user account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SwapExactOutInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 15 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 15, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_in", len(accountKeys)-1)
	}
	obj.UserTokenIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_out account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_out", len(accountKeys)-1)
	}
	obj.UserTokenOut = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set host_fee_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "host_fee_in", len(accountKeys)-1)
	}
	obj.HostFeeIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user", len(accountKeys)-1)
	}
	obj.User = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SwapExactOutInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.UserTokenIn)
	keys = append(keys, obj.UserTokenOut)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.HostFeeIn)
	keys = append(keys, obj.User)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *SwapExactOutInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SwapExactOutInstruction: %w", err)
	}
	return nil
}

func UnmarshalSwapExactOutInstruction(buf []byte) (*SwapExactOutInstruction, error) {
	obj := new(SwapExactOutInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SwapExactOut2Instruction struct {
	MaxInAmount           uint64                `json:"max_in_amount"`
	OutAmount             uint64                `json:"out_amount"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	UserTokenIn                     solanago.PublicKey `json:"user_token_in"`
	UserTokenInWritable             bool               `json:"user_token_in_writable"`
	UserTokenOut                    solanago.PublicKey `json:"user_token_out"`
	UserTokenOutWritable            bool               `json:"user_token_out_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	HostFeeIn                       solanago.PublicKey `json:"host_fee_in"`
	HostFeeInWritable               bool               `json:"host_fee_in_writable"`
	HostFeeInOptional               bool               `json:"host_fee_in_optional"`
	User                            solanago.PublicKey `json:"user"`
	UserSigner                      bool               `json:"user_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	MemoProgram                     solanago.PublicKey `json:"memo_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *SwapExactOut2Instruction) GetDiscriminator() []byte {
	return Instruction_SwapExactOut2[:]
}

func (obj *SwapExactOut2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `MaxInAmount`:
	err = decoder.Decode(&obj.MaxInAmount)
	if err != nil {
		return err
	}
	// Deserialize `OutAmount`:
	err = decoder.Decode(&obj.OutAmount)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SwapExactOut2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from user_token_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_in", err)
	}
	indices = append(indices, index)
	// Decode from user_token_out account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_out", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from host_fee_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "host_fee_in", err)
	}
	indices = append(indices, index)
	// Decode from user account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SwapExactOut2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_in", len(accountKeys)-1)
	}
	obj.UserTokenIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_out account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_out", len(accountKeys)-1)
	}
	obj.UserTokenOut = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set host_fee_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "host_fee_in", len(accountKeys)-1)
	}
	obj.HostFeeIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user", len(accountKeys)-1)
	}
	obj.User = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SwapExactOut2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.UserTokenIn)
	keys = append(keys, obj.UserTokenOut)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.HostFeeIn)
	keys = append(keys, obj.User)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.MemoProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *SwapExactOut2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SwapExactOut2Instruction: %w", err)
	}
	return nil
}

func UnmarshalSwapExactOut2Instruction(buf []byte) (*SwapExactOut2Instruction, error) {
	obj := new(SwapExactOut2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SwapWithPriceImpactInstruction struct {
	AmountIn          uint64 `json:"amount_in"`
	ActiveId          *int32 `json:"active_id"`
	MaxPriceImpactBps uint16 `json:"max_price_impact_bps"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	UserTokenIn                     solanago.PublicKey `json:"user_token_in"`
	UserTokenInWritable             bool               `json:"user_token_in_writable"`
	UserTokenOut                    solanago.PublicKey `json:"user_token_out"`
	UserTokenOutWritable            bool               `json:"user_token_out_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	HostFeeIn                       solanago.PublicKey `json:"host_fee_in"`
	HostFeeInWritable               bool               `json:"host_fee_in_writable"`
	HostFeeInOptional               bool               `json:"host_fee_in_optional"`
	User                            solanago.PublicKey `json:"user"`
	UserSigner                      bool               `json:"user_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *SwapWithPriceImpactInstruction) GetDiscriminator() []byte {
	return Instruction_SwapWithPriceImpact[:]
}

func (obj *SwapWithPriceImpactInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `AmountIn`:
	err = decoder.Decode(&obj.AmountIn)
	if err != nil {
		return err
	}
	// Deserialize `ActiveId`:
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ActiveId)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `MaxPriceImpactBps`:
	err = decoder.Decode(&obj.MaxPriceImpactBps)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SwapWithPriceImpactInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from user_token_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_in", err)
	}
	indices = append(indices, index)
	// Decode from user_token_out account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_out", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from host_fee_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "host_fee_in", err)
	}
	indices = append(indices, index)
	// Decode from user account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SwapWithPriceImpactInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 15 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 15, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_in", len(accountKeys)-1)
	}
	obj.UserTokenIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_out account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_out", len(accountKeys)-1)
	}
	obj.UserTokenOut = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set host_fee_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "host_fee_in", len(accountKeys)-1)
	}
	obj.HostFeeIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user", len(accountKeys)-1)
	}
	obj.User = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SwapWithPriceImpactInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.UserTokenIn)
	keys = append(keys, obj.UserTokenOut)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.HostFeeIn)
	keys = append(keys, obj.User)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *SwapWithPriceImpactInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SwapWithPriceImpactInstruction: %w", err)
	}
	return nil
}

func UnmarshalSwapWithPriceImpactInstruction(buf []byte) (*SwapWithPriceImpactInstruction, error) {
	obj := new(SwapWithPriceImpactInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SwapWithPriceImpact2Instruction struct {
	AmountIn              uint64                `json:"amount_in"`
	ActiveId              *int32                `json:"active_id"`
	MaxPriceImpactBps     uint16                `json:"max_price_impact_bps"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	LbPair                          solanago.PublicKey `json:"lb_pair"`
	LbPairWritable                  bool               `json:"lb_pair_writable"`
	BinArrayBitmapExtension         solanago.PublicKey `json:"bin_array_bitmap_extension"`
	BinArrayBitmapExtensionOptional bool               `json:"bin_array_bitmap_extension_optional"`
	ReserveX                        solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable                bool               `json:"reserve_x_writable"`
	ReserveY                        solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable                bool               `json:"reserve_y_writable"`
	UserTokenIn                     solanago.PublicKey `json:"user_token_in"`
	UserTokenInWritable             bool               `json:"user_token_in_writable"`
	UserTokenOut                    solanago.PublicKey `json:"user_token_out"`
	UserTokenOutWritable            bool               `json:"user_token_out_writable"`
	TokenXMint                      solanago.PublicKey `json:"token_x_mint"`
	TokenYMint                      solanago.PublicKey `json:"token_y_mint"`
	Oracle                          solanago.PublicKey `json:"oracle"`
	OracleWritable                  bool               `json:"oracle_writable"`
	HostFeeIn                       solanago.PublicKey `json:"host_fee_in"`
	HostFeeInWritable               bool               `json:"host_fee_in_writable"`
	HostFeeInOptional               bool               `json:"host_fee_in_optional"`
	User                            solanago.PublicKey `json:"user"`
	UserSigner                      bool               `json:"user_signer"`
	TokenXProgram                   solanago.PublicKey `json:"token_x_program"`
	TokenYProgram                   solanago.PublicKey `json:"token_y_program"`
	MemoProgram                     solanago.PublicKey `json:"memo_program"`
	EventAuthority                  solanago.PublicKey `json:"event_authority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *SwapWithPriceImpact2Instruction) GetDiscriminator() []byte {
	return Instruction_SwapWithPriceImpact2[:]
}

func (obj *SwapWithPriceImpact2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `AmountIn`:
	err = decoder.Decode(&obj.AmountIn)
	if err != nil {
		return err
	}
	// Deserialize `ActiveId`:
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ActiveId)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `MaxPriceImpactBps`:
	err = decoder.Decode(&obj.MaxPriceImpactBps)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SwapWithPriceImpact2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_bitmap_extension account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_bitmap_extension", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from user_token_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_in", err)
	}
	indices = append(indices, index)
	// Decode from user_token_out account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user_token_out", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from oracle account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "oracle", err)
	}
	indices = append(indices, index)
	// Decode from host_fee_in account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "host_fee_in", err)
	}
	indices = append(indices, index)
	// Decode from user account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "user", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SwapWithPriceImpact2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 16 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 16, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_bitmap_extension account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_bitmap_extension", len(accountKeys)-1)
	}
	obj.BinArrayBitmapExtension = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_in", len(accountKeys)-1)
	}
	obj.UserTokenIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user_token_out account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user_token_out", len(accountKeys)-1)
	}
	obj.UserTokenOut = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set oracle account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "oracle", len(accountKeys)-1)
	}
	obj.Oracle = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set host_fee_in account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "host_fee_in", len(accountKeys)-1)
	}
	obj.HostFeeIn = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set user account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "user", len(accountKeys)-1)
	}
	obj.User = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SwapWithPriceImpact2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayBitmapExtension)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.UserTokenIn)
	keys = append(keys, obj.UserTokenOut)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.Oracle)
	keys = append(keys, obj.HostFeeIn)
	keys = append(keys, obj.User)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.MemoProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *SwapWithPriceImpact2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SwapWithPriceImpact2Instruction: %w", err)
	}
	return nil
}

func UnmarshalSwapWithPriceImpact2Instruction(buf []byte) (*SwapWithPriceImpact2Instruction, error) {
	obj := new(SwapWithPriceImpact2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateBaseFeeParametersInstruction struct {
	FeeParameter BaseFeeParameter `json:"fee_parameter"`

	// Accounts:
	LbPair         solanago.PublicKey `json:"lb_pair"`
	LbPairWritable bool               `json:"lb_pair_writable"`
	Admin          solanago.PublicKey `json:"admin"`
	AdminSigner    bool               `json:"admin_signer"`
	EventAuthority solanago.PublicKey `json:"event_authority"`
	Program        solanago.PublicKey `json:"program"`
}

func (obj *UpdateBaseFeeParametersInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateBaseFeeParameters[:]
}

func (obj *UpdateBaseFeeParametersInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `FeeParameter`:
	err = decoder.Decode(&obj.FeeParameter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateBaseFeeParametersInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateBaseFeeParametersInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateBaseFeeParametersInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *UpdateBaseFeeParametersInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateBaseFeeParametersInstruction: %w", err)
	}
	return nil
}

func UnmarshalUpdateBaseFeeParametersInstruction(buf []byte) (*UpdateBaseFeeParametersInstruction, error) {
	obj := new(UpdateBaseFeeParametersInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateDynamicFeeParametersInstruction struct {
	FeeParameter DynamicFeeParameter `json:"fee_parameter"`

	// Accounts:
	LbPair         solanago.PublicKey `json:"lb_pair"`
	LbPairWritable bool               `json:"lb_pair_writable"`
	Admin          solanago.PublicKey `json:"admin"`
	AdminSigner    bool               `json:"admin_signer"`
	EventAuthority solanago.PublicKey `json:"event_authority"`
	Program        solanago.PublicKey `json:"program"`
}

func (obj *UpdateDynamicFeeParametersInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateDynamicFeeParameters[:]
}

func (obj *UpdateDynamicFeeParametersInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `FeeParameter`:
	err = decoder.Decode(&obj.FeeParameter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateDynamicFeeParametersInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateDynamicFeeParametersInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateDynamicFeeParametersInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *UpdateDynamicFeeParametersInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateDynamicFeeParametersInstruction: %w", err)
	}
	return nil
}

func UnmarshalUpdateDynamicFeeParametersInstruction(buf []byte) (*UpdateDynamicFeeParametersInstruction, error) {
	obj := new(UpdateDynamicFeeParametersInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateFeesAndReward2Instruction struct {
	MinBinId int32 `json:"min_bin_id"`
	MaxBinId int32 `json:"max_bin_id"`

	// Accounts:
	Position         solanago.PublicKey `json:"position"`
	PositionWritable bool               `json:"position_writable"`
	LbPair           solanago.PublicKey `json:"lb_pair"`
	LbPairWritable   bool               `json:"lb_pair_writable"`
	Owner            solanago.PublicKey `json:"owner"`
	OwnerSigner      bool               `json:"owner_signer"`
}

func (obj *UpdateFeesAndReward2Instruction) GetDiscriminator() []byte {
	return Instruction_UpdateFeesAndReward2[:]
}

func (obj *UpdateFeesAndReward2Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `MinBinId`:
	err = decoder.Decode(&obj.MinBinId)
	if err != nil {
		return err
	}
	// Deserialize `MaxBinId`:
	err = decoder.Decode(&obj.MaxBinId)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateFeesAndReward2Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateFeesAndReward2Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateFeesAndReward2Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Owner)
	return keys
}

func (obj *UpdateFeesAndReward2Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateFeesAndReward2Instruction: %w", err)
	}
	return nil
}

func UnmarshalUpdateFeesAndReward2Instruction(buf []byte) (*UpdateFeesAndReward2Instruction, error) {
	obj := new(UpdateFeesAndReward2Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateFeesAndRewardsInstruction struct {

	// Accounts:
	Position              solanago.PublicKey `json:"position"`
	PositionWritable      bool               `json:"position_writable"`
	LbPair                solanago.PublicKey `json:"lb_pair"`
	LbPairWritable        bool               `json:"lb_pair_writable"`
	BinArrayLower         solanago.PublicKey `json:"bin_array_lower"`
	BinArrayLowerWritable bool               `json:"bin_array_lower_writable"`
	BinArrayUpper         solanago.PublicKey `json:"bin_array_upper"`
	BinArrayUpperWritable bool               `json:"bin_array_upper_writable"`
	Owner                 solanago.PublicKey `json:"owner"`
	OwnerSigner           bool               `json:"owner_signer"`
}

func (obj *UpdateFeesAndRewardsInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateFeesAndRewards[:]
}

func (obj *UpdateFeesAndRewardsInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	return nil
}

func (obj *UpdateFeesAndRewardsInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_lower account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_lower", err)
	}
	indices = append(indices, index)
	// Decode from bin_array_upper account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array_upper", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateFeesAndRewardsInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_lower account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_lower", len(accountKeys)-1)
	}
	obj.BinArrayLower = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array_upper account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array_upper", len(accountKeys)-1)
	}
	obj.BinArrayUpper = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateFeesAndRewardsInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.BinArrayLower)
	keys = append(keys, obj.BinArrayUpper)
	keys = append(keys, obj.Owner)
	return keys
}

func (obj *UpdateFeesAndRewardsInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateFeesAndRewardsInstruction: %w", err)
	}
	return nil
}

func UnmarshalUpdateFeesAndRewardsInstruction(buf []byte) (*UpdateFeesAndRewardsInstruction, error) {
	obj := new(UpdateFeesAndRewardsInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdatePositionOperatorInstruction struct {
	Operator solanago.PublicKey `json:"operator"`

	// Accounts:
	Position         solanago.PublicKey `json:"position"`
	PositionWritable bool               `json:"position_writable"`
	Owner            solanago.PublicKey `json:"owner"`
	OwnerSigner      bool               `json:"owner_signer"`
	EventAuthority   solanago.PublicKey `json:"event_authority"`
	Program          solanago.PublicKey `json:"program"`
}

func (obj *UpdatePositionOperatorInstruction) GetDiscriminator() []byte {
	return Instruction_UpdatePositionOperator[:]
}

func (obj *UpdatePositionOperatorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `Operator`:
	err = decoder.Decode(&obj.Operator)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdatePositionOperatorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from position account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "position", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdatePositionOperatorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set position account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "position", len(accountKeys)-1)
	}
	obj.Position = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdatePositionOperatorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Position)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *UpdatePositionOperatorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdatePositionOperatorInstruction: %w", err)
	}
	return nil
}

func UnmarshalUpdatePositionOperatorInstruction(buf []byte) (*UpdatePositionOperatorInstruction, error) {
	obj := new(UpdatePositionOperatorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateRewardDurationInstruction struct {
	RewardIndex uint64 `json:"reward_index"`
	NewDuration uint64 `json:"new_duration"`

	// Accounts:
	LbPair           solanago.PublicKey `json:"lb_pair"`
	LbPairWritable   bool               `json:"lb_pair_writable"`
	Admin            solanago.PublicKey `json:"admin"`
	AdminSigner      bool               `json:"admin_signer"`
	BinArray         solanago.PublicKey `json:"bin_array"`
	BinArrayWritable bool               `json:"bin_array_writable"`
	EventAuthority   solanago.PublicKey `json:"event_authority"`
	Program          solanago.PublicKey `json:"program"`
}

func (obj *UpdateRewardDurationInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateRewardDuration[:]
}

func (obj *UpdateRewardDurationInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `RewardIndex`:
	err = decoder.Decode(&obj.RewardIndex)
	if err != nil {
		return err
	}
	// Deserialize `NewDuration`:
	err = decoder.Decode(&obj.NewDuration)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateRewardDurationInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from bin_array account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateRewardDurationInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array", len(accountKeys)-1)
	}
	obj.BinArray = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateRewardDurationInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.BinArray)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *UpdateRewardDurationInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateRewardDurationInstruction: %w", err)
	}
	return nil
}

func UnmarshalUpdateRewardDurationInstruction(buf []byte) (*UpdateRewardDurationInstruction, error) {
	obj := new(UpdateRewardDurationInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateRewardFunderInstruction struct {
	RewardIndex uint64             `json:"reward_index"`
	NewFunder   solanago.PublicKey `json:"new_funder"`

	// Accounts:
	LbPair         solanago.PublicKey `json:"lb_pair"`
	LbPairWritable bool               `json:"lb_pair_writable"`
	Admin          solanago.PublicKey `json:"admin"`
	AdminSigner    bool               `json:"admin_signer"`
	EventAuthority solanago.PublicKey `json:"event_authority"`
	Program        solanago.PublicKey `json:"program"`
}

func (obj *UpdateRewardFunderInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateRewardFunder[:]
}

func (obj *UpdateRewardFunderInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `RewardIndex`:
	err = decoder.Decode(&obj.RewardIndex)
	if err != nil {
		return err
	}
	// Deserialize `NewFunder`:
	err = decoder.Decode(&obj.NewFunder)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateRewardFunderInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "admin", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateRewardFunderInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "admin", len(accountKeys)-1)
	}
	obj.Admin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateRewardFunderInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.Admin)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *UpdateRewardFunderInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateRewardFunderInstruction: %w", err)
	}
	return nil
}

func UnmarshalUpdateRewardFunderInstruction(buf []byte) (*UpdateRewardFunderInstruction, error) {
	obj := new(UpdateRewardFunderInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type WithdrawIneligibleRewardInstruction struct {
	RewardIndex           uint64                `json:"reward_index"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	LbPair                     solanago.PublicKey `json:"lb_pair"`
	LbPairWritable             bool               `json:"lb_pair_writable"`
	RewardVault                solanago.PublicKey `json:"reward_vault"`
	RewardVaultWritable        bool               `json:"reward_vault_writable"`
	RewardMint                 solanago.PublicKey `json:"reward_mint"`
	FunderTokenAccount         solanago.PublicKey `json:"funder_token_account"`
	FunderTokenAccountWritable bool               `json:"funder_token_account_writable"`
	Funder                     solanago.PublicKey `json:"funder"`
	FunderSigner               bool               `json:"funder_signer"`
	BinArray                   solanago.PublicKey `json:"bin_array"`
	BinArrayWritable           bool               `json:"bin_array_writable"`
	TokenProgram               solanago.PublicKey `json:"token_program"`
	MemoProgram                solanago.PublicKey `json:"memo_program"`
	EventAuthority             solanago.PublicKey `json:"event_authority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *WithdrawIneligibleRewardInstruction) GetDiscriminator() []byte {
	return Instruction_WithdrawIneligibleReward[:]
}

func (obj *WithdrawIneligibleRewardInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `RewardIndex`:
	err = decoder.Decode(&obj.RewardIndex)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WithdrawIneligibleRewardInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from reward_vault account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_vault", err)
	}
	indices = append(indices, index)
	// Decode from reward_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reward_mint", err)
	}
	indices = append(indices, index)
	// Decode from funder_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder_token_account", err)
	}
	indices = append(indices, index)
	// Decode from funder account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "funder", err)
	}
	indices = append(indices, index)
	// Decode from bin_array account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bin_array", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	// Decode from event_authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "event_authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *WithdrawIneligibleRewardInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_vault account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_vault", len(accountKeys)-1)
	}
	obj.RewardVault = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reward_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reward_mint", len(accountKeys)-1)
	}
	obj.RewardMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder_token_account", len(accountKeys)-1)
	}
	obj.FunderTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set funder account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "funder", len(accountKeys)-1)
	}
	obj.Funder = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bin_array account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bin_array", len(accountKeys)-1)
	}
	obj.BinArray = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set event_authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "event_authority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *WithdrawIneligibleRewardInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.RewardVault)
	keys = append(keys, obj.RewardMint)
	keys = append(keys, obj.FunderTokenAccount)
	keys = append(keys, obj.Funder)
	keys = append(keys, obj.BinArray)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.MemoProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

func (obj *WithdrawIneligibleRewardInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling WithdrawIneligibleRewardInstruction: %w", err)
	}
	return nil
}

func UnmarshalWithdrawIneligibleRewardInstruction(buf []byte) (*WithdrawIneligibleRewardInstruction, error) {
	obj := new(WithdrawIneligibleRewardInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type WithdrawProtocolFeeInstruction struct {
	MaxAmountX            uint64                `json:"max_amount_x"`
	MaxAmountY            uint64                `json:"max_amount_y"`
	RemainingAccountsInfo RemainingAccountsInfo `json:"remaining_accounts_info"`

	// Accounts:
	LbPair                 solanago.PublicKey `json:"lb_pair"`
	LbPairWritable         bool               `json:"lb_pair_writable"`
	ReserveX               solanago.PublicKey `json:"reserve_x"`
	ReserveXWritable       bool               `json:"reserve_x_writable"`
	ReserveY               solanago.PublicKey `json:"reserve_y"`
	ReserveYWritable       bool               `json:"reserve_y_writable"`
	TokenXMint             solanago.PublicKey `json:"token_x_mint"`
	TokenYMint             solanago.PublicKey `json:"token_y_mint"`
	ReceiverTokenX         solanago.PublicKey `json:"receiver_token_x"`
	ReceiverTokenXWritable bool               `json:"receiver_token_x_writable"`
	ReceiverTokenY         solanago.PublicKey `json:"receiver_token_y"`
	ReceiverTokenYWritable bool               `json:"receiver_token_y_writable"`
	ClaimFeeOperator       solanago.PublicKey `json:"claim_fee_operator"`
	Operator               solanago.PublicKey `json:"operator"`
	OperatorSigner         bool               `json:"operator_signer"`
	TokenXProgram          solanago.PublicKey `json:"token_x_program"`
	TokenYProgram          solanago.PublicKey `json:"token_y_program"`
	MemoProgram            solanago.PublicKey `json:"memo_program"`
}

func (obj *WithdrawProtocolFeeInstruction) GetDiscriminator() []byte {
	return Instruction_WithdrawProtocolFee[:]
}

func (obj *WithdrawProtocolFeeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Deserialize `MaxAmountX`:
	err = decoder.Decode(&obj.MaxAmountX)
	if err != nil {
		return err
	}
	// Deserialize `MaxAmountY`:
	err = decoder.Decode(&obj.MaxAmountY)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAccountsInfo`:
	err = decoder.Decode(&obj.RemainingAccountsInfo)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WithdrawProtocolFeeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from lb_pair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "lb_pair", err)
	}
	indices = append(indices, index)
	// Decode from reserve_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_x", err)
	}
	indices = append(indices, index)
	// Decode from reserve_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reserve_y", err)
	}
	indices = append(indices, index)
	// Decode from token_x_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_mint", err)
	}
	indices = append(indices, index)
	// Decode from token_y_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_mint", err)
	}
	indices = append(indices, index)
	// Decode from receiver_token_x account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "receiver_token_x", err)
	}
	indices = append(indices, index)
	// Decode from receiver_token_y account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "receiver_token_y", err)
	}
	indices = append(indices, index)
	// Decode from claim_fee_operator account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "claim_fee_operator", err)
	}
	indices = append(indices, index)
	// Decode from operator account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operator", err)
	}
	indices = append(indices, index)
	// Decode from token_x_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_x_program", err)
	}
	indices = append(indices, index)
	// Decode from token_y_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_y_program", err)
	}
	indices = append(indices, index)
	// Decode from memo_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "memo_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *WithdrawProtocolFeeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 12 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 12, len(indices))
	}
	indexOffset := 0
	// Set lb_pair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "lb_pair", len(accountKeys)-1)
	}
	obj.LbPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_x", len(accountKeys)-1)
	}
	obj.ReserveX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reserve_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reserve_y", len(accountKeys)-1)
	}
	obj.ReserveY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_mint", len(accountKeys)-1)
	}
	obj.TokenXMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_mint", len(accountKeys)-1)
	}
	obj.TokenYMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set receiver_token_x account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "receiver_token_x", len(accountKeys)-1)
	}
	obj.ReceiverTokenX = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set receiver_token_y account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "receiver_token_y", len(accountKeys)-1)
	}
	obj.ReceiverTokenY = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set claim_fee_operator account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "claim_fee_operator", len(accountKeys)-1)
	}
	obj.ClaimFeeOperator = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set operator account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operator", len(accountKeys)-1)
	}
	obj.Operator = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_x_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_x_program", len(accountKeys)-1)
	}
	obj.TokenXProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_y_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_y_program", len(accountKeys)-1)
	}
	obj.TokenYProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set memo_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "memo_program", len(accountKeys)-1)
	}
	obj.MemoProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *WithdrawProtocolFeeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.LbPair)
	keys = append(keys, obj.ReserveX)
	keys = append(keys, obj.ReserveY)
	keys = append(keys, obj.TokenXMint)
	keys = append(keys, obj.TokenYMint)
	keys = append(keys, obj.ReceiverTokenX)
	keys = append(keys, obj.ReceiverTokenY)
	keys = append(keys, obj.ClaimFeeOperator)
	keys = append(keys, obj.Operator)
	keys = append(keys, obj.TokenXProgram)
	keys = append(keys, obj.TokenYProgram)
	keys = append(keys, obj.MemoProgram)
	return keys
}

func (obj *WithdrawProtocolFeeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling WithdrawProtocolFeeInstruction: %w", err)
	}
	return nil
}

func UnmarshalWithdrawProtocolFeeInstruction(buf []byte) (*WithdrawProtocolFeeInstruction, error) {
	obj := new(WithdrawProtocolFeeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts // If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AddLiquidity:
		instruction := new(AddLiquidityInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLiquidityInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddLiquidity2:
		instruction := new(AddLiquidity2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLiquidity2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddLiquidityByStrategy:
		instruction := new(AddLiquidityByStrategyInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLiquidityByStrategyInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddLiquidityByStrategy2:
		instruction := new(AddLiquidityByStrategy2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLiquidityByStrategy2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddLiquidityByStrategyOneSide:
		instruction := new(AddLiquidityByStrategyOneSideInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLiquidityByStrategyOneSideInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddLiquidityByWeight:
		instruction := new(AddLiquidityByWeightInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLiquidityByWeightInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddLiquidityOneSide:
		instruction := new(AddLiquidityOneSideInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLiquidityOneSideInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddLiquidityOneSidePrecise:
		instruction := new(AddLiquidityOneSidePreciseInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLiquidityOneSidePreciseInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddLiquidityOneSidePrecise2:
		instruction := new(AddLiquidityOneSidePrecise2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLiquidityOneSidePrecise2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClaimFee:
		instruction := new(ClaimFeeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClaimFeeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClaimFee2:
		instruction := new(ClaimFee2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClaimFee2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClaimReward:
		instruction := new(ClaimRewardInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClaimRewardInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClaimReward2:
		instruction := new(ClaimReward2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClaimReward2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CloseClaimProtocolFeeOperator:
		instruction := new(CloseClaimProtocolFeeOperatorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CloseClaimProtocolFeeOperatorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClosePosition:
		instruction := new(ClosePositionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClosePositionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClosePosition2:
		instruction := new(ClosePosition2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClosePosition2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClosePositionIfEmpty:
		instruction := new(ClosePositionIfEmptyInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClosePositionIfEmptyInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClosePresetParameter:
		instruction := new(ClosePresetParameterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClosePresetParameterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClosePresetParameter2:
		instruction := new(ClosePresetParameter2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClosePresetParameter2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CreateClaimProtocolFeeOperator:
		instruction := new(CreateClaimProtocolFeeOperatorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CreateClaimProtocolFeeOperatorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_DecreasePositionLength:
		instruction := new(DecreasePositionLengthInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as DecreasePositionLengthInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ForIdlTypeGenerationDoNotCall:
		instruction := new(ForIdlTypeGenerationDoNotCallInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ForIdlTypeGenerationDoNotCallInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_FundReward:
		instruction := new(FundRewardInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as FundRewardInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_GoToABin:
		instruction := new(GoToABinInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as GoToABinInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_IncreaseOracleLength:
		instruction := new(IncreaseOracleLengthInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as IncreaseOracleLengthInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_IncreasePositionLength:
		instruction := new(IncreasePositionLengthInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as IncreasePositionLengthInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeBinArray:
		instruction := new(InitializeBinArrayInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeBinArrayInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeBinArrayBitmapExtension:
		instruction := new(InitializeBinArrayBitmapExtensionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeBinArrayBitmapExtensionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeCustomizablePermissionlessLbPair:
		instruction := new(InitializeCustomizablePermissionlessLbPairInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeCustomizablePermissionlessLbPairInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeCustomizablePermissionlessLbPair2:
		instruction := new(InitializeCustomizablePermissionlessLbPair2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeCustomizablePermissionlessLbPair2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeLbPair:
		instruction := new(InitializeLbPairInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeLbPairInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeLbPair2:
		instruction := new(InitializeLbPair2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeLbPair2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializePermissionLbPair:
		instruction := new(InitializePermissionLbPairInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializePermissionLbPairInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializePosition:
		instruction := new(InitializePositionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializePositionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializePositionByOperator:
		instruction := new(InitializePositionByOperatorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializePositionByOperatorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializePositionPda:
		instruction := new(InitializePositionPdaInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializePositionPdaInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializePresetParameter:
		instruction := new(InitializePresetParameterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializePresetParameterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializePresetParameter2:
		instruction := new(InitializePresetParameter2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializePresetParameter2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeReward:
		instruction := new(InitializeRewardInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeRewardInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeTokenBadge:
		instruction := new(InitializeTokenBadgeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeTokenBadgeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_MigrateBinArray:
		instruction := new(MigrateBinArrayInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as MigrateBinArrayInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_MigratePosition:
		instruction := new(MigratePositionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as MigratePositionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RebalanceLiquidity:
		instruction := new(RebalanceLiquidityInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RebalanceLiquidityInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveAllLiquidity:
		instruction := new(RemoveAllLiquidityInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveAllLiquidityInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveLiquidity:
		instruction := new(RemoveLiquidityInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveLiquidityInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveLiquidity2:
		instruction := new(RemoveLiquidity2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveLiquidity2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveLiquidityByRange:
		instruction := new(RemoveLiquidityByRangeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveLiquidityByRangeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveLiquidityByRange2:
		instruction := new(RemoveLiquidityByRange2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveLiquidityByRange2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetActivationPoint:
		instruction := new(SetActivationPointInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetActivationPointInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetPairStatus:
		instruction := new(SetPairStatusInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetPairStatusInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetPairStatusPermissionless:
		instruction := new(SetPairStatusPermissionlessInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetPairStatusPermissionlessInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetPreActivationDuration:
		instruction := new(SetPreActivationDurationInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetPreActivationDurationInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetPreActivationSwapAddress:
		instruction := new(SetPreActivationSwapAddressInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetPreActivationSwapAddressInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Swap:
		instruction := new(SwapInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SwapInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Swap2:
		instruction := new(Swap2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as Swap2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SwapExactOut:
		instruction := new(SwapExactOutInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SwapExactOutInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SwapExactOut2:
		instruction := new(SwapExactOut2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SwapExactOut2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SwapWithPriceImpact:
		instruction := new(SwapWithPriceImpactInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SwapWithPriceImpactInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SwapWithPriceImpact2:
		instruction := new(SwapWithPriceImpact2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SwapWithPriceImpact2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateBaseFeeParameters:
		instruction := new(UpdateBaseFeeParametersInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateBaseFeeParametersInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateDynamicFeeParameters:
		instruction := new(UpdateDynamicFeeParametersInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateDynamicFeeParametersInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateFeesAndReward2:
		instruction := new(UpdateFeesAndReward2Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateFeesAndReward2Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateFeesAndRewards:
		instruction := new(UpdateFeesAndRewardsInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateFeesAndRewardsInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdatePositionOperator:
		instruction := new(UpdatePositionOperatorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdatePositionOperatorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateRewardDuration:
		instruction := new(UpdateRewardDurationInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateRewardDurationInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateRewardFunder:
		instruction := new(UpdateRewardFunderInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateRewardFunderInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_WithdrawIneligibleReward:
		instruction := new(WithdrawIneligibleRewardInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as WithdrawIneligibleRewardInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_WithdrawProtocolFee:
		instruction := new(WithdrawProtocolFeeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as WithdrawProtocolFeeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
